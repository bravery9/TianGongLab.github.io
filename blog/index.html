<!doctype html>
<html lang="zh-Hans" dir="ltr" class="blog-wrapper blog-list-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.3">
<title data-rh="true">Blog | 破壳漏洞挖掘平台文档系统</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://poc.qianxin.com/img/poc-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://poc.qianxin.com/img/poc-social-card.jpg"><meta data-rh="true" property="og:url" content="https://poc.qianxin.com/blog"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" property="og:title" content="Blog | 破壳漏洞挖掘平台文档系统"><meta data-rh="true" name="description" content="Blog"><meta data-rh="true" property="og:description" content="Blog"><meta data-rh="true" name="docusaurus_tag" content="blog_posts_list"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_posts_list"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://poc.qianxin.com/blog"><link data-rh="true" rel="alternate" href="https://poc.qianxin.com/blog" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://poc.qianxin.com/blog" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="破壳漏洞挖掘平台文档系统 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="破壳漏洞挖掘平台文档系统 Atom Feed"><link rel="stylesheet" href="/assets/css/styles.d85ec5c3.css">
<link rel="preload" href="/assets/js/runtime~main.0118f860.js" as="script">
<link rel="preload" href="/assets/js/main.f99e6d73.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top navbarHideable_m1mJ"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">破壳平台文档系统</b></a><a class="navbar__item navbar__link" href="/docs/quickstart">教程</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">博客</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_nlXk"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>简体中文</a><ul class="dropdown__menu"><li><a href="/blog" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="zh-Hans">简体中文</a></li></ul></div><a href="https://poc.qianxin.com/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">破壳官网<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/analysis-of-pseudorandom-number-problems">伪随机数问题浅析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/research-on-windows-kernel-race-condition-vulnerabilities">Windows内核竞态条件漏洞研究</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/microsoft-hyper-vtpm">Microsoft Hyper-V 虚拟 TPM 设备漏洞分析</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><meta itemprop="description" content="前言"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/analysis-of-pseudorandom-number-problems">伪随机数问题浅析</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-11-03T00:00:00.000Z" itemprop="datePublished">2023年11月3日</time> · <!-- -->阅读需 18 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><span itemprop="name">王垚</span></div><small class="avatar__subtitle" itemprop="description">安全研究员 @奇安信-天工实验室</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="前言">前言<a href="#前言" class="hash-link" aria-label="前言的直接链接" title="前言的直接链接">​</a></h2><p>随机数在许多科学和工程领域扮演着重要角色，尤其在计算机科学和信息安全领域，它的重要意义更是不可小觑。在这个全球数字化的时代，数据是我们经济和生活的核心，数据的安全和保密显得尤为重要。我们使用密码保护我们的银行账户、电子邮件、社交媒体账户，我们使用加密技术保护我们通信的隐私性。在这些过程中，随机数是其中最重要的一部分，它用于密码生成、数据加密、身份验证和网络协议安全，是保证电子交流安全的令牌。如果我们不能保证所生成的随机数实际上是随机的，那么它们就可能被预测，这将让我们面临安全风险。因此，在探讨随机数的同时，我们须深化理解随机性的安全性，以便更有效地使用随机数，保护自身和数据免受攻击。</p><p>本次分享的两个案例（CVE-2023-42820和CVE-2022-35890）均是由于随机数使用不当从而导致了更加严重的安全问题</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="随机数相关基础知识">随机数相关基础知识<a href="#随机数相关基础知识" class="hash-link" aria-label="随机数相关基础知识的直接链接" title="随机数相关基础知识的直接链接">​</a></h2><p>根据密码学原理，随机数的随机性检验可以分为三个标准：</p><ol><li>统计学伪随机性：在给定的随机比特流样本中，1的数量大致等于0的数量，满足这类要求的数字在人类“一眼看上去”是随机的</li><li>密码学安全伪随机性：给定随机样本的一部分和随机算法，不能有效的演算出随机样本的剩余部分</li><li>真随机性：随机样本不可重现</li></ol><p>相应的，随机数也分为三类：</p><ol><li><p><strong>伪随机数</strong>：满足第一个条件的随机数</p></li><li><p><strong>密码学安全的伪随机数</strong>：同时满足前两个条件的随机数，可以通过密码学安全伪随机数生成器计算得出</p></li><li><p><strong>真随机数</strong>：同时满足三个条件的随机数</p><ul><li>密码学安全伪随机数生成器（CSPRNG）</li></ul><p>相较于统计学伪随机数生成器和更弱的伪随机数生成器，CSPRNG所生成的密码学安全伪随机数具有额外的伪随机属性，简单来说CSPRNG本质上属于一种单向函数</p><p> <img loading="lazy" alt="随机数分类与关系图" src="/assets/images/25e7fb3b-96a3-4eac-87c0-7f570b849279-c4e876978ac0e1dded9bfc991a531436.png" title=" =627x219" width="1920" height="670" class="img_ev3q"></p></li></ol><p>这是一个使用python random库生成随机数的例子</p><div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token operator" style="color:#393A34">&gt;&gt;</span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">import</span><span class="token plain"> random</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">&gt;&gt;</span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> random.seed</span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#36acaa">123</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">&gt;&gt;</span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> random.random</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token number" style="color:#36acaa">0.052363598850944326</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">&gt;&gt;</span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> random.random</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token number" style="color:#36acaa">0.08718667752263232</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">&gt;&gt;</span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> random.seed</span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#36acaa">123</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">&gt;&gt;</span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> random.random</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token number" style="color:#36acaa">0.052363598850944326</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">&gt;&gt;</span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> random.random</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token number" style="color:#36acaa">0.08718667752263232</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">&gt;&gt;</span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> random.random</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token number" style="color:#36acaa">0.4072417636703983</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">&gt;&gt;</span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> random.seed</span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#36acaa">123</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">&gt;&gt;</span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> random.random</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token number" style="color:#36acaa">0.052363598850944326</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>对于随机数的使用，一般是先播种，然后使用rand来获取随机数。不播种会使用默认的种子，不同的语言不通版本种子可能不一样。这种通过rand出来的随机数，就是伪随机数，只要种子固定那么每次生成的随机数序列就会一样，同时通过上面的例子，可以发现以下特点：</p><ul><li><p>在播种后会重置随机序列</p></li><li><p>random.seed() 进行播种时并没有产生新的对象，就会对后面的random产生影响，那么推断<strong>播种后种子对播种时的整个进程生效</strong></p><ul><li>对于Java这种有新对象生成的语言来说，如果每次都是调用的同一个对象，那么与上面的情况一致，<strong>播种后会对这个对象后面生成的随机数产生影响</strong></li></ul><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class A{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Random random;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void init(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long seed = 123456L;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.random = new Random(seed);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.init();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int num = this.random.nextInt(100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int num2 = this.random.nextInt(100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(num + &quot; &quot; + num2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="案例1jumpserver-任意账户密码重置cve-2023-42820">案例1——JumpServer 任意账户密码重置(CVE-2023-42820)<a href="#案例1jumpserver-任意账户密码重置cve-2023-42820" class="hash-link" aria-label="案例1——JumpServer 任意账户密码重置(CVE-2023-42820)的直接链接" title="案例1——JumpServer 任意账户密码重置(CVE-2023-42820)的直接链接">​</a></h2><blockquote><p><em>JumpServer 是广受欢迎的国产开源堡垒机，是符合 4A 规范的专业运维安全审计系统</em></p></blockquote><p><strong>漏洞位于找回密码时，生成的6位验证码算法是伪随机，伪随机的种子可获取，从而可以预测验证码，最终重置任意账户密码</strong></p><p>jumperserver找回密码时的流程如下图（这里借用一个知识星球中的流程图</p><p> <img loading="lazy" src="/assets/images/d840c8a2-98ab-433f-9af9-dbef59d82ffb-02f96f540e225fa2657a29ca38f05c9f.png" title=" =538x513" width="896" height="854" class="img_ev3q"></p><p>看起来流程似乎没有问题，但问题出现在<strong>随机数种子</strong>在请求验证码图片时直接展示给用户，下面从源码入手查看逻辑</p><p>先看验证码生成的逻辑</p><div class="language-python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-python codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">def</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">captcha_image</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">request</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> key</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> scale</span><span class="token operator" style="color:#393A34">=</span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">if</span><span class="token plain"> scale </span><span class="token operator" style="color:#393A34">==</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">2</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">and</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">not</span><span class="token plain"> settings</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">CAPTCHA_2X_IMAGE</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">raise</span><span class="token plain"> Http404</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">try</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        store </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> CaptchaStore</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">objects</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">get</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">hashkey</span><span class="token operator" style="color:#393A34">=</span><span class="token plain">key</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">except</span><span class="token plain"> CaptchaStore</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">DoesNotExist</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token comment" style="color:#999988;font-style:italic"># HTTP 410 Gone status so that crawlers don&#x27;t index these expired urls.</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">return</span><span class="token plain"> HttpResponse</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">status</span><span class="token operator" style="color:#393A34">=</span><span class="token number" style="color:#36acaa">410</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    random</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">seed</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">key</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic"># Do not generate different images for the same key</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                            </span><span class="token comment" style="color:#999988;font-style:italic"># 这里的种子是外面传进来的参数</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    text </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> store</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">challenge</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><a href="https://github.com/mbi/django-simple-captcha/blob/master/captcha/views.py" target="_blank" rel="noopener noreferrer">https://github.com/mbi/django-simple-captcha/blob/master/captcha/views.py</a></p><p>寻找这个函数的调用处</p><div class="language-python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-python codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">from</span><span class="token plain"> django</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">urls </span><span class="token keyword" style="color:#00009f">import</span><span class="token plain"> re_path</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">from</span><span class="token plain"> captcha </span><span class="token keyword" style="color:#00009f">import</span><span class="token plain"> views</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">urlpatterns </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    re_path</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token string" style="color:#e3116c">r&quot;image/(?P&lt;key&gt;\w+)/$&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        views</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">captcha_image</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        name</span><span class="token operator" style="color:#393A34">=</span><span class="token string" style="color:#e3116c">&quot;captcha-image&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        kwargs</span><span class="token operator" style="color:#393A34">=</span><span class="token punctuation" style="color:#393A34">{</span><span class="token string" style="color:#e3116c">&quot;scale&quot;</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    re_path</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token string" style="color:#e3116c">r&quot;image/(?P&lt;key&gt;\w+)@2/$&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        views</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">captcha_image</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        name</span><span class="token operator" style="color:#393A34">=</span><span class="token string" style="color:#e3116c">&quot;captcha-image-2x&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        kwargs</span><span class="token operator" style="color:#393A34">=</span><span class="token punctuation" style="color:#393A34">{</span><span class="token string" style="color:#e3116c">&quot;scale&quot;</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">2</span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    re_path</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">r&quot;audio/(?P&lt;key&gt;\w+).wav$&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> views</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">captcha_audio</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> name</span><span class="token operator" style="color:#393A34">=</span><span class="token string" style="color:#e3116c">&quot;captcha-audio&quot;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    re_path</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">r&quot;refresh/$&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> views</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">captcha_refresh</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> name</span><span class="token operator" style="color:#393A34">=</span><span class="token string" style="color:#e3116c">&quot;captcha-refresh&quot;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">]</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><a href="https://github.com/mbi/django-simple-captcha/blob/master/captcha/urls.py#L9" target="_blank" rel="noopener noreferrer">https://github.com/mbi/django-simple-captcha/blob/master/captcha/urls.py#L9</a></p><p>可以发现key的值就存在于请求的url中，如下</p><p> <img loading="lazy" src="/assets/images/90c8eae3-425b-4b89-89ae-fd933b7ddf01-f36aaeac6089c1bb655d69c0e91e91ef.png" width="1080" height="142" class="img_ev3q"></p><p>这样就满足了随机数种子可知的条件</p><p>再看密码找回地方的逻辑</p><p> <img loading="lazy" src="/assets/images/bb7fd835-eebe-4b21-a9e7-c1eaa1f7e5a3-f06193bcc235d972c841b6a9ec74b52a.png" width="1080" height="570" class="img_ev3q"></p><p>这里可以发现生成验证码也使用random函数，并且没有进行重新播种，故后续的随机序列完全可以计算出来，从而导致6位验证码可以直接计算出来</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="修复"><strong>修复</strong><a href="#修复" class="hash-link" aria-label="修复的直接链接" title="修复的直接链接">​</a></h3><p><a href="https://github.com/jumpserver/jumpserver/commit/ce645b1710c5821119f313e1b3d801470565aac" target="_blank" rel="noopener noreferrer">fix: 修复 random error · jumpserver/jumpserver@ce645b1 · GitHub</a></p><p> <img loading="lazy" src="/assets/images/80ed7e56-6479-4e15-8d03-805762876ac8-303a4ff4c68a734c2eb0cf43ce198d15.png" width="1138" height="551" class="img_ev3q"></p><p>patch是直接重新将None作为种子进行播种</p><blockquote><p><em>random.seed(a=None, version=2) If a is omitted or None , the current system time is used. If randomness sources are provided by the operating system, they are used instead of the system time (see the os.urandom() function for details on availability).</em></p></blockquote><p>查看手册，使用None作为种子，则</p><ul><li>使用系统提供的随机数发生器（/dev/urandom）作为种子</li><li>使用当前时间作为种子</li></ul><p>这样就避免了生成6位验证码时，种子已知从而可以被预测后续随机数的情况</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="案例2inductive-ignition-session劫持cve-2022-35890">案例2——Inductive Ignition session劫持(CVE-2022-35890)<a href="#案例2inductive-ignition-session劫持cve-2022-35890" class="hash-link" aria-label="案例2——Inductive Ignition session劫持(CVE-2022-35890)的直接链接" title="案例2——Inductive Ignition session劫持(CVE-2022-35890)的直接链接">​</a></h2><blockquote><p><em>Inductive Automation Ignition是美国Inductive Automation公司的一套用于SCADA系统的集成软件平台。该平台支持SCADA（数据采集与监控系统）、HMI（人机界面）等</em></p></blockquote><blockquote><p>ignition 是2022年pwn2own的比赛项目，该漏洞在比赛中被使用。</p></blockquote><p><strong>漏洞源于生成session使用的算法在Windows下为伪随机函数，且未使用默认种子，还可以通过特定方法泄露出seed大概范围，最终结合一定次数的爆破即可劫持真正session</strong></p><p>先看种子初始化的部分</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private void initRandom() throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    long seed = System.currentTimeMillis();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char[] entropy = ENTROPY;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; entropy.length; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long update = (byte)entropy[i] &lt;&lt; i % 8 * 8;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        seed ^= update;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.random = new SecureRandom();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.random.setSeed(seed);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.digest = MessageDigest.getInstance(&quot;SHA-1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>initRandom位于GatewaySessionManager刚启动时，这里初始化了种子，使用的随机函数为java.security.SecureRandom()</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public GWSession createSession() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    GWSession session = new GWSession(this.generateSessionId());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    session.startup(this.context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.sessions.put(session.getId(), session);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.log.debug((Object)(&quot;Created new session: &quot; + session.getPublicId()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.statusTags.refresh();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return session;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>创建session位于用户成功登录处，再看具体生成session的算法</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">protected synchronized String generateSessionId() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    byte[] random = new byte[16];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String result = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    StringBuffer buffer = new StringBuffer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    do {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int resultLenBytes = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (result != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            buffer = new StringBuffer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ++this.duplicates;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (resultLenBytes &lt; this.sessionIdLength) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.random.nextBytes(random);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            random = this.digest.digest(random);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int j = 0; j &lt; random.length &amp;&amp; resultLenBytes &lt; this.sessionIdLength; ++resultLenBytes, ++j) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                byte b1 = (byte)((random[j] &amp; 0xF0) &gt;&gt; 4);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                byte b2 = (byte)(random[j] &amp; 0xF);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (b1 &lt; 10) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    buffer.append((char)(48 + b1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    buffer.append((char)(65 + (b1 - 10)));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (b2 &lt; 10) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    buffer.append((char)(48 + b2));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                buffer.append((char)(65 + (b2 - 10)));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } while (this.sessions.get(result = buffer.toString()) != null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这里使用了this.random生成随机数，也就是上面播种了时间戳作为种子的随机函数，那么可能存在被预测的风险</p><p>查询java.security.SecureRandom在windows平台上底层调用的函数，在stack overflow上找到了类似的问题</p><ul><li><p>Q: <em>I am interested in</em> <code>java.util.Random</code> and <code>java.security.SecureRandom</code> classes. I found that <code>Random</code> uses system clock to generate seed and <code>SecureRandom</code> uses <code>/dev/random</code> or <code>/dev/urandom</code> but these files are on Linux, while on Windows it uses some mistic <code>CryptGenRandom</code>. Even if that is super secure function, do we know from where does it take values? What is the basement to generate seed?</p><blockquote><p>我对 java.util.Random 和 java.security.SecureRandom 类感兴趣。 我发现 Random 使用系统时钟生成种子，SecureRandom 使用 /dev/random 或 /dev/urandom，但这些文件位于 Linux 上，而在 Windows 上则使用一些神秘的 CryptGenRandom。 即使这是超级安全的函数，我们知道它从哪里获取值吗？ 生成种子的底层逻辑是什么？</p></blockquote></li><li><p>A: <em>In Windows SecureRandom uses the method CryptGenRandom that is part of WinCrypt Windows library (Included in Advapi32.dll of Windows System libraries).</em></p><blockquote><p>在 Windows SecureRandom 中，使用 CryptGenRandom 方法，该方法是 WinCrypt Windows 库的一部分（包含在 Windows 系统库的 Advapi32.dll 中）</p></blockquote></li></ul><p>下面是微软官方手册对<em>CryptGenRandom</em>的描述（节选）</p><ul><li><p><em>Software random number generators work in fundamentally the same way. They start with a random number, known as the seed, and then use an algorithm to generate a pseudo-random sequence of bits based on it. The most difficult part of this process is to get a seed that is truly random. This is usually based on user input latency, or the jitter from one or more hardware components.</em></p><blockquote><p>软件随机数生成器的工作方式基本相同。 他们从一个随机数（称为种子）开始，然后使用算法生成基于它的<!-- -->`<strong>伪随机位序列</strong>。 这个过程中最困难的部分是获得真正随机的种子。 这通常基于用户输入延迟或来自一个或多个硬件组件的抖动。</p></blockquote></li></ul><p>通过手册，我们可知Windows底层调用的是个伪随机函数，并且默认情况下使用的种子是一个很难预测的值，但是ignition中错误的使用了系统时间作为种子</p><p><strong>如何获得伪随机种子？</strong></p><p>在ignition gateway中，有一个特殊的servlet，<code>scriptModules</code> 用于获取第三方的脚本，最终将其打包返回一个zip</p><p>直接跟到对应逻辑处</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void zipThirdPartyScriptModulesAndCalcHash() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      this.thirdPartyZipValid = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      Object object = this.thirdPartyZipLock;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      synchronized (object) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          if (this.thirdPartyZipValid) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              File pylibDir = this.getThirdPartyScriptModulesDir();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              ZipMap zipMap = new ZipMap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              this.addDirToZip(pylibDir, pylibDir, zipMap);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              File tempFile = new File(this.systemManager.getTempDir(), &quot;pylib_compressed.zip&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              zipMap.writeToFile(tempFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              this.thirdPartyScriptModulesHash = Files.hash((File)tempFile, (HashFunction)Hashing.md5()).toString();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              this.log.error(&quot;Error calculating 3rd party script zip hash.&quot;, (Throwable)e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              this.thirdPartyScriptModulesHash = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              this.thirdPartyZipValid = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              this.thirdPartyZipLock.notifyAll();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>pylib_compressed.zip在每次ignition启动时都会重新生成，对于文件来说会有一个最后修改时间的属性，同时上面所说的随机数初始化时使用的时间戳也会与这个时间接近</p><p>查看启动日志可以看到先生成了seed后启动ignition gateway，那么只需要在zip的最后修改时间值减去delay即可，一般来说2s足矣</p><p><strong>那么在爆破seed时如何知道当前session是否正确？</strong></p><p>在gateway中处理数据包时存在如下逻辑</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">if (!versionHash.isDev() &amp;&amp; msg.getVersion() != 0L &amp;&amp; versionHash.getHash() != msg.getVersion()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (session != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            session.setMaxInactiveInterval(10);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.printErrorResponse((PrintWriter)out, 309, &quot;Version mismatch&quot;, false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>此处逻辑位于session校验之后，也就是说故意设置错误的version，当session验证通过时，即可在返回包中看到309的响应</p><p>至此完成了整个session劫持的流程</p><p>重新梳理一下整个流程：</p><p>通过scriptModules获取到ignition启动的时间 → 将时间-delay作为初始种子 → 使用初始种子计算session → 验证当前session是否正确 → 种子+1（直至正确）</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="修复-1">修复<a href="#修复-1" class="hash-link" aria-label="修复的直接链接" title="修复的直接链接">​</a></h3><p>查看修复后的版本代码</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">protected synchronized String generateSessionId() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    do {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        result = AuthUtil.generateRandomBase64String(32);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } while(this.sessions.get(result) != null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>新版本直接删掉了initRandom函数，并修改了生成session的逻辑，跟进</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public static String generateRandomBase64String(int entropyCountInBytes) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      assert entropyCountInBytes &gt; 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      byte[] bytes = new byte[entropyCountInBytes];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      SecureRandomProvider.get().nextBytes(bytes);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return BASE64_ENCODER.encodeToString(bytes);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>继续跟进</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public void nextBytes(byte[] bytes) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      LOG.tracef(&quot;nextBytes(bytes.length=%s)...&quot;, new Object[]{bytes.length});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      this.secureRandom.nextBytes(bytes);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      LOG.trace(&quot;Done.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>看到使用的函数仍然是伪随机函数，查看seed是否可以推测</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private SecureRandomProvider() throws NoSuchAlgorithmException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    LOG.debug(&quot;Creating SecureRandom object...&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.secureRandom = SecureRandom.getInstance(&quot;SHA1PRNG&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    byte[] seed = new byte[128];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (new Random()).nextBytes(seed);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.secureRandom.setSeed(seed);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.secureRandom.nextBytes(new byte[128]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (new Thread(new SeedGenerator(), &quot;secure-random-seed-gen&quot;)).start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    LOG.debug(&quot;... SecureRandom Created.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这里seed生成虽然使用了伪随机函数random().nextbytes()，（random函数默认使用timestamp作为种子）但是由于每次生成session时都需要调用一遍这个流程，使用的seed为当前时间，所以每次生成session时的seed没法通过之前的方法进行推测，从而使得session的值不可计算，最终防止了session被劫持的风险</p><p>这里还有另一种修复方法，即使用java.security.SecureRandom默认种子即可，不进行setseed</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="漏洞模式总结">漏洞模式总结<a href="#漏洞模式总结" class="hash-link" aria-label="漏洞模式总结的直接链接" title="漏洞模式总结的直接链接">​</a></h2><p>使用不安全的随机函数 → 种子可知/可预测 → 随机数可计算 → 造成更严重的安全问题</p><p>上面的两个案例的修复方法均是对种子进行处理，防止种子可以被预测，从而修复原有的安全问题</p><p>同样，也可以通过将<strong>伪随机函数</strong>修改为<strong>安全随机函数</strong>的方法来解决上述安全问题（但安全随机函数可能并没有伪随机函数效率高）</p><table><thead><tr><th>语言</th><th>常见伪随机函数</th><th>安全随机函数</th></tr></thead><tbody><tr><td>C</td><td>srand</td><td>linux 使用/dev/urandom</td></tr><tr><td></td><td>rand</td><td>Windows使用CryptGenRandom并使用默认种子</td></tr><tr><td>C++</td><td>mt19937</td><td>C++使用std::random_device 类来获取安全的随机种子</td></tr><tr><td></td><td>default_random_engine</td><td></td></tr><tr><td>python</td><td>random</td><td>secrets</td></tr><tr><td>java</td><td>java.security.SecureRandom  //强伪随机函数</td><td>SecureRandom.getInstanceStrong</td></tr><tr><td></td><td>java.util.Random   //弱伪随机数</td><td></td></tr><tr><td>php</td><td>mt_scrand   mt_rand</td><td>random_bytes</td></tr><tr><td>C#</td><td>Random</td><td>System.Security.Cryptography.RNGCryptoServiceProvider</td></tr><tr><td>golang</td><td>math/rand</td><td>crypto/rand</td></tr></tbody></table><p>如果种子不可预测，那么伪随机数序列就难以预测，称为强伪随机数</p><p>如果种子可预测，那么随机数序列就通常可以预测，称为弱随机数</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="reference">Reference<a href="#reference" class="hash-link" aria-label="Reference的直接链接" title="Reference的直接链接">​</a></h2><p><a href="https://mp.weixin.qq.com/s/VShjaDI1McerX843YyOENw" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/VShjaDI1McerX843YyOENw</a></p><p><a href="https://github.com/vulhub/vulhub/blob/master/jumpserver/CVE-2023-42820/README.zh-cn.md" target="_blank" rel="noopener noreferrer">https://github.com/vulhub/vulhub/blob/master/jumpserver/CVE-2023-42820/README.zh-cn.md</a></p><p><a href="https://www.leavesongs.com/PENETRATION/jumpserver-sep-2023-multiple-vulnerabilities-go-through.html" target="_blank" rel="noopener noreferrer">https://www.leavesongs.com/PENETRATION/jumpserver-sep-2023-multiple-vulnerabilities-go-through.html</a></p><p><a href="https://github.com/sourceincite/randy" target="_blank" rel="noopener noreferrer">https://github.com/sourceincite/randy</a></p><p><a href="https://stackoverflow.com/questions/53496652/seed-to-java-security-securerandom-on-windows-os" target="_blank" rel="noopener noreferrer">https://stackoverflow.com/questions/53496652/seed-to-java-security-securerandom-on-windows-os</a></p><p><a href="https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptgenrandom" target="_blank" rel="noopener noreferrer">https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptgenrandom</a></p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="作者及介绍">作者及介绍<a href="#作者及介绍" class="hash-link" aria-label="作者及介绍的直接链接" title="作者及介绍的直接链接">​</a></h2><p>作者：王垚</p><p>简介：奇安信天工实验室安全研究员，Datacon2022/Datcon2021出题人，Geekpwn2019选手。</p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/cryptography">Cryptography</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><meta itemprop="description" content="Windows内核竞态条件漏洞研究"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/research-on-windows-kernel-race-condition-vulnerabilities">Windows内核竞态条件漏洞研究</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-11-01T00:00:00.000Z" itemprop="datePublished">2023年11月1日</time> · <!-- -->阅读需 30 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><span itemprop="name">张书樵</span></div><small class="avatar__subtitle" itemprop="description">实习生 @奇安信-天工实验室, 研究生 @清华大学</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><p>Windows内核竞态条件漏洞研究</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="一研究背景">一、研究背景<a href="#一研究背景" class="hash-link" aria-label="一、研究背景的直接链接" title="一、研究背景的直接链接">​</a></h2><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="一操作系统内核漏洞">（一）操作系统内核漏洞<a href="#一操作系统内核漏洞" class="hash-link" aria-label="（一）操作系统内核漏洞的直接链接" title="（一）操作系统内核漏洞的直接链接">​</a></h3><p>操作系统是计算机系统的核心软件，其主要功能在于管理计算机系统中的各种软硬件资源，并为计算机用户和用户程序提供访问这些资源的统一抽象。为达到这一设计目标，操作系统内核通常运行在称为内核态的高特权级执行环境中。一旦操作系统内核被恶意攻击者非法侵入，攻击者便可立即拥有对整个计算机系统的控制权，造成极大危害。因此，针对操作系统内核的漏洞挖掘一直是学术界和工业界的研究重点。</p><p>Windows操作系统是桌面计算机领域最广泛应用的操作系统之一，在网络空间中扮演着至关重要的角色。与之对应的，Windows操作系统中存在的安全漏洞也往往具有广泛的影响和严重的潜在危害。攻击者可以利用这些漏洞来进行大规模的网络攻击，给网络安全带来严重的威胁。例如，在2017年流行的WannaCry勒索病毒攻击，就是利用了MS17-010“永恒之蓝”漏洞，其受害者遍布全球多国，造成了巨大的损失。</p><p>在Linux操作系统上，以Syzkaller为代表的模糊测试工具可以7x24小时不间断地对内核进行漏洞挖掘，并自动化地生成漏洞报告供维护者查阅。然而，在Windows操作系统上，还没有出现影响力和测试效果能够比拟Syzkaller的开源工具。造成这一差异的原因是多方面的，例如，研究人员可以通过对Linux源码进行静态分析得到供Syzkaller使用的Syzlang模版，其中包含对系统调用接口的完整描述，由此可以驱动模糊测试。但在Windows上，由于内核是闭源的，对其系统调用接口的分析过程更为复杂和困难。</p><p>通过分析近年来披露的Windows内核态漏洞，我们发现，这些漏洞大多是由独立的研究人员或安全研究团队发现，并且极大地依赖于专家知识，只在特定的情况下使用了模糊测试等自动化方法来辅助漏洞挖掘。奇安信天工实验室近年来在Hyper-V中发现的漏洞，也同样离不开安全研究员对Hyper-V整体架构和漏洞模式的深入理解。</p><p>有鉴于此，笔者也针对近年来披露的Windows内核态漏洞进行了人工的分析和研究，并主要聚焦于竞态条件这一漏洞类型。本文便是对相关研究发现的总结。</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="二竞态条件漏洞">（二）竞态条件漏洞<a href="#二竞态条件漏洞" class="hash-link" aria-label="（二）竞态条件漏洞的直接链接" title="（二）竞态条件漏洞的直接链接">​</a></h3><p>竞态条件是计算机科学中的一个重要概念，它指的是在多线程或多进程环境中，由于不恰当的同步操作或竞争资源的访问而导致的不确定性行为。在现代操作系统中，多线程的程序调度是至关重要的一项任务，它直接影响了计算机系统的性能和资源利用效率。多线程编程允许程序同时执行多个任务，从而提高了系统的响应速度和并发处理能力。然而，为了有效地管理这些线程，操作系统必须具备高效的调度机制，决定哪个线程获得CPU时间片，以确保各个线程能够合理地分享计算资源。这一调度决策是基于一系列算法和策略进行的，涉及到线程的优先级、状态管理、抢占机制以及资源争用解决等多个方面。</p><p>这一调度机制也导致多个线程或进程在争夺资源的同时，执行顺序并不确定，因此可能会产生意想不到的结果。为了避免问题，多线程场景下对关键资源的访问需要利用加锁、同步等机制来保证安全。倘若多个线程同时访问共享变量或资源，而没有适当的同步机制来保护这些资源，这可能导致数据损坏、程序崩溃或不一致的结果，从而带来严重的安全和可靠性问题。</p><p> <img loading="lazy" src="/assets/images/8f35fffb-2a4c-4308-b51c-272595afbdcb-8c8372529b11e89980f93cf3cd0ea77e.png" width="1182" height="926" class="img_ev3q"></p><p><em>图1：典型的竞态条件成因，两个线程无保护地访问同一个内核对象</em></p><p>如图1所示，漏洞CVE-2022-29142的原因正是两个线程可以同时访问同一个内核对象，如果其中一个线程试图关闭该对象的句柄，另一个线程便可能访问已被释放的指针。</p><p>本文将会具体介绍竞态条件漏洞带来的潜在风险，并描述复现真实存在于Windows内核中的竞态条件漏洞时的发现。</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="二漏洞分析采用的关键技术">二、漏洞分析采用的关键技术<a href="#二漏洞分析采用的关键技术" class="hash-link" aria-label="二、漏洞分析采用的关键技术的直接链接" title="二、漏洞分析采用的关键技术的直接链接">​</a></h2><p>在进行针对Windows内核的漏洞分析和研究时，主要采用的关键技术包括：补丁对比分析、二进制逆向分析、竞态条件构建和调试等。</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="一补丁对比及二进制逆向分析">（一）补丁对比及二进制逆向分析<a href="#一补丁对比及二进制逆向分析" class="hash-link" aria-label="（一）补丁对比及二进制逆向分析的直接链接" title="（一）补丁对比及二进制逆向分析的直接链接">​</a></h3><p>通过在CVE数据库中的检索，发现近年来披露的Windows内核漏洞中不乏用户提权和任意代码执行等高危漏洞。然而，由于微软积极控制漏洞的影响，相关漏洞的公开PoC程序数量相对较少。对于那些没有公开PoC的漏洞，往往只能获得漏洞发现者通过博客或社交媒体透露的少量信息，难以由此开展系统性的漏洞研究。考虑到这些漏洞的修复补丁存在于Windows安全更新中，通过对补丁进行分析，包括进行补丁的解包和二进制对比等，能够有效地从中提取出更新内容，识别受影响的模块，并可以进一步地从中提取关键的补丁点，由此分析补丁所修复的漏洞。</p><p>为了能够解析微软的Windows安全补丁，首先需要了解补丁的格式以及获取方法。打包补丁的文件格式包括：.MSU（Microsoft Standalone Update）和.CAB（Cabinet）格式。补丁一般会作为 Windows 更新的一部分自动分发到用户设备上，但也可以直接从微软的更新目录中下载独立的补丁。此前，微软主要提供顺序的更新包，它们必须依次安装到用户的系统中。如今，更新以累积的方式提供，这意味着基本系统版本中的所有必需更新都包含在补丁包中，这也允许用户平滑地升级系统版本。此外，出于节省带宽等考虑，许多更新以增量的方式分发，即：更新包中只包含对特定二进制目标的修补方式，而不包含全部的文件。这也进一步增加了补丁分析的难度。</p><p>对于每次安全更新，具体的补丁文件可以从Microsoft Update Catalog上获取。.MSU格式的补丁在使用expand.exe程序解包后，将能够获得.CAB格式的补丁文件，且这些文件按照指令集和二进制差异类型进行命名。对于补丁内容的进一步提取，将依赖于微软提供的msdelta.dll库。该库中提供了ApplyDelta系列函数用于执行Windows系统更新。通过C或Python语言调用相关库函数，即可实现打补丁的过程，获得补丁之后的二进制文件。</p><p> <img loading="lazy" src="/assets/images/a27f91a3-347a-464e-a3ba-da2e949a07d9-e4e81c81cb311cb22df19b1dc1c0d474.jpeg" width="1270" height="688" class="img_ev3q"></p><p><em>图2：漏洞CVE-2023-21537补丁对比</em></p><p>最后，通过BinDiff或Diaphora等二进制对比工具，即可完成对补丁内容的分析，并由此定位到漏洞点。如图2所示，以漏洞CVE-2023-21537为例，通过对比分析补丁前后的函数控制流图，可以发现补丁新增了参数检查的分支（见红色框）。在确定可能的漏洞点后，即可开展人工的逆向分析。</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="二windows内核调试">（二）Windows内核调试<a href="#二windows内核调试" class="hash-link" aria-label="（二）Windows内核调试的直接链接" title="（二）Windows内核调试的直接链接">​</a></h3><p>在成功确定漏洞点后，下一步是构造PoC程序，并触发漏洞行为，例如使内核出现崩溃，造成蓝屏死机（Blue Screen of Death）。再此基础上，可以进一步构造漏洞利用的方式，例如，利用释放后使用（Use after free）漏洞来覆盖关键的内核数据结构，实现进程提权的效果。</p><p>为了触发内核中的漏洞代码的执行，需要构造用户态程序执行系统调用或驱动程序的IoControl调用。这些函数调用往往需要大量的参数，并且，参数需要满足一定的约束条件。在实际的测试中，发现通过人工构造的参数难以一次性通过检查，必须不断进行调试并修改PoC程序。</p><p>微软提供了WinDbg程序用于支持Windows内核调试，但由于在内核函数中触发断点等操作会中断整个系统的执行，因而必须在另一台计算机上运行WinDbg，并通过TCP连接至待调试的计算机。在实际的实验中，相关的内核调试借助Hyper-V虚拟机完成。经笔者测试，运行在Hyper-V虚拟机中的Windows系统开启内核调试模式并设置端口和密钥参数后，即可在Host上通过WinDbg程序开启TCP连接进行内核调试。</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="三典型漏洞分析">三、典型漏洞分析<a href="#三典型漏洞分析" class="hash-link" aria-label="三、典型漏洞分析的直接链接" title="三、典型漏洞分析的直接链接">​</a></h2><p>笔者总共分析和研究了10个近年来被披露并分配了CVE编号的Windows内核竞态条件安全漏洞，具体的漏洞编号、内核模块和漏洞类型情况如表1所示。下面将通过案例分析介绍其中的典型漏洞，以及对未来针对此类漏洞进行自动化挖掘的启发。</p><table><thead><tr><th><strong>CVE ID</strong></th><th><strong>内核模块</strong></th><th><strong>漏洞类型</strong></th></tr></thead><tbody><tr><td>CVE-2018-7249</td><td>secdrv.sys</td><td>UAF</td></tr><tr><td>CVE-2018-8410</td><td>ntoskrnl</td><td>Double dereference</td></tr><tr><td>CVE-2018-8611</td><td>ntoskrnl</td><td>UAF</td></tr><tr><td>CVE-2020-1015</td><td>UMPS</td><td>UAF</td></tr><tr><td>CVE-2021-26868</td><td>win32k</td><td>UAF</td></tr><tr><td>CVE-2021-40449</td><td>win32k</td><td>UAF</td></tr><tr><td>CVE-2021-41335</td><td>ntoskrnl</td><td>OOB</td></tr><tr><td>CVE-2022-29142</td><td>ntoskrnl</td><td>UAF</td></tr><tr><td>CVE-2023-21536</td><td>ETW</td><td>UAF</td></tr><tr><td>CVE-2023-21537</td><td>mqac.sys</td><td>Double fetch</td></tr></tbody></table><p><em>表1：分析研究的Windows内核竞态条件安全漏洞</em></p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="一cve-2018-7249漏洞分析">（一）CVE-2018-7249漏洞分析<a href="#一cve-2018-7249漏洞分析" class="hash-link" aria-label="（一）CVE-2018-7249漏洞分析的直接链接" title="（一）CVE-2018-7249漏洞分析的直接链接">​</a></h3><p>该漏洞存在于Windows的secdrv.sys驱动程序中，是一个UAF类型的漏洞。该漏洞的复现版本为Windows 7 7600。</p><p>secdrv.sys驱动程序提供了IoControl调用号为0x0CA002813的接口，其处理函数sub_11A88接收三种不同的输入参数：0x96、0x97和0x98，并根据参数调用不同的派发函数。其中：0x96从分页内存池中分配内存块，进行初始化操作，并将其中一部分复制到用户提供的缓冲区中（此处还存在一个未初始化访问的问题，导致内核态的16比特内存泄漏到用户态）。0x97读取先前由0x96分配的块，并对用户输入缓冲区进行加密。0x98则用于释放由0x96分配的块。</p><p> <img loading="lazy" src="/assets/images/056ed014-f8db-4676-83ed-bb31e609f25c-f11ad28b8a89ede0ec4e4ce3fe6cb540.png" width="982" height="980" class="img_ev3q"></p><p><em>图3：处理函数根据输入参数a2执行不同操作</em></p><p>当调用IoControl类型0x97时，它通过标签找到之前由类型0x96分配的内存块。这里的漏洞在于，0x97使用内存的过程缺少加锁和同步机制。在其操作内存期间，这段内存可能被释放，因此如果恶意攻击者成功赢得竞态条件，将触发释放后使用的问题。进一步地，如果攻击者在IoControl类型0x97的操作期间，使用类型0x98成功释放了块，并重新分配了一个由攻击者控制的新块到完全相同的内存位置，那么这将有可能最终劫持驱动程序的执行控制流，并在内核态执行任意代码。由于0x97中的加密函数在用户提供的缓冲区上执行，这个缓冲区可以非常大，因此加密可能需要很长时间才能执行，从而为IoControl类型0x98提供了完美的时间窗口来达成竞态条件。</p><p>该漏洞存在公开的Exp程序，经过简单调试后即可稳定实现漏洞利用，获得SYSTEM权限。</p><p> <img loading="lazy" src="/assets/images/73734e47-cf9a-4702-b521-4979d61a1286-27908a5844a46b36699f2bb658d8578c.png" width="1220" height="922" class="img_ev3q"></p><p><em>图4：复现漏洞CVE-2018-7249实现提权</em></p><p>该漏洞的触发方式较为简单，且输入参数也没有较为苛刻的约束条件，因而通过自动化漏洞挖掘工具发现该漏洞是可能的。现有的竞态条件漏洞挖掘方案可以自动由顺序执行的IoControl调用序列生成多线程的序列，并探索不同线程交错的情况下其执行过程是否出现异常。不过，这仍需要先通过对驱动程序的分析，推断出相关的IoControl调用号，并指导模糊测试器通过启动多个线程来分别执行0x97和0x98对应的IoControl操作。有关问题仍需进一步研究。</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="二cve-2021-41335漏洞分析">（二）CVE-2021-41335漏洞分析<a href="#二cve-2021-41335漏洞分析" class="hash-link" aria-label="（二）CVE-2021-41335漏洞分析的直接链接" title="（二）CVE-2021-41335漏洞分析的直接链接">​</a></h3><p>该漏洞存在于Windows的内核ntoskrnl.exe中。漏洞的原因是两个内核函数：ObpCreateSymbolicLinkName与ObpDeleteSymbolicLinkName可能操作同一个_OBJECT_SYMBOLIC_LINK内核对象，但它们并未正确进行加锁操作，因而存在竞态条件安全漏洞。该漏洞将导致越界访问，并可以被进一步利用，导致内核任意地址写，造成严重的破坏。该漏洞的复现版本为Windows 10 21H1 19043.928。</p><p>触发漏洞的调用链是：NtCreateSymbolicLinkObject系统调用会执行ObInsertObjectEx来创建符号链接对象，该函数先调用ObpCreateHandle来为新的符号链接对象创建一个新的句柄，再调用ObpCreateSymbolicLinkName创建符号链接。然而，在ObpCreateHandle执行结束后，用户态程序就已经拥有了指向内核对象的有效句柄。这意味着，在随后ObInsertObjectEx调用ObpCreateSymbolicLinkName时，用户态进程可以开启另一个线程并尝试通过该句柄操作仍在被内核函数使用的新符号链接对象。例如，可以在另一个线程中通过NtClose函数调用关闭该句柄，这显然会导致问题。</p><p>为了进一步明确漏洞的成因，通过人工逆向分析比较ObpCreateSymbolicLinkName和ObpDeleteSymbolicLinkName的代码，可以注意到：ObpDeleteSymbolicLinkName将符号链接对象的DosDeviceDriveIndex成员设置为0；而ObpCreateSymbolicLinkName读取符号链接对象的该成员并将其减小1。此外，ObpCreateSymbolicLinkName使用减小后的DosDeviceDriveIndex值作为_DEVICE_MAP结构中的DriveType数组的索引。</p><p> <img loading="lazy" src="/assets/images/6bdd1ff7-570c-45a9-8d71-4e9d73d46c2d-e43cb7e5bc65b84549b82e925778d30e.png" width="1274" height="1180" class="img_ev3q"></p><p><em>图5：符号链接对象的DosDeviceDriveIndex成员被置零</em></p><p>由于加锁操作存在问题，恶意攻击者可以试图使DosDeviceDriveIndex成员已经被置零后，又进行自减操作，由此产生整数下溢。又由于该数值被用于数组索引，这将导致越界访问。</p><p>为了复现此漏洞，需要创建两个线程，第一个线程通过NtCreateSymbolicLinkObject不断创建新的符号链接对象，而第二个线程则通过NtClose不断关闭新创建的符号链接对象句柄。通过这样做，很可能出现ObpDeleteSymbolicLinkName在ObpCreateSymbolicLinkName之前被调用的线程交错情况。因此，ObpCreateSymbolicLinkName将以值0xFFFFFFFF作为索引访问DriveType数组，导致在数组边界之外写入任意值，最终引发内核崩溃。具体的漏洞复现情况和调试器读出的寄存器参数如图6、图7所示，可以看到，执行NtClose的线程进行了多于35万次尝试，才触发了导致漏洞的线程交错方式。</p><p> <img loading="lazy" src="/assets/images/d8149816-c428-416a-b8f3-fe5a5ee93574-64209c21135234a19298873b28eff60b.png" width="1269" height="790" class="img_ev3q"></p><p><em>图6：运行PoC程序，两个线程分别创建和销毁内核对象</em></p><p> <img loading="lazy" src="/assets/images/d72340f0-03f2-441d-8c4f-c134330f15fe-605795e57db2a13dd7d4bb50149fa171.png" width="1270" height="730" class="img_ev3q"></p><p><em>图7：WinDbg捕获蓝屏死机的情况，可见rcx寄存器值存在整数下溢</em></p><p>通过补丁对比分析可以发现，该漏洞的修复方式是由ObpCreateHandle来调用ObpCreateSymbolicLinkName创建符号链接，避免用户态进程提前对句柄进行操作。</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="三cve-2023-21537漏洞分析">（三）CVE-2023-21537漏洞分析<a href="#三cve-2023-21537漏洞分析" class="hash-link" aria-label="（三）CVE-2023-21537漏洞分析的直接链接" title="（三）CVE-2023-21537漏洞分析的直接链接">​</a></h3><p>该漏洞于2023年1月披露，并已被微软修复。漏洞并没有公开的PoC程序，漏洞发现者只通过博客文章透露了部分信息。该漏洞的复现版本为Windows 10 21H1 19043.928。</p><p>该漏洞存在于消息队列（MSMQ）驱动程序mqac.sys中。消息队列是Windows的可选功能，需要在控制面板中手动启用，并在计算机管理中创建消息队列。微软为消息队列的开发提供了头文件mq.h以及运行时库mqrt.dll，其中包含MQOpenQueue和MQSendMessage等函数。这些函数其实是封装了对驱动程序mqac.sys发起的IoControl调用，通过构造合法的参数，用户态程序也可以直接使用NtDeviceIoControlFile发送IoControl调用，触发此驱动程序的功能。</p><p>该漏洞的成因是mqac.sys中的ACSendMessage函数会两次读取一个来自用户的输入参数，第一次该参数用于控制数组长度，第二次则是在释放堆内存时，根据该长度进行释放。然而，这段逻辑并未考虑参数会被用户修改的可能，因而构成一个Double fetch漏洞，可能导致错误的内存被释放。</p><p>mqac.sys中负责处理IoControl调用的函数名称为ACDeviceControl，该函数将会解析用户传入的参数，并调用不同的派发函数。通过逆向分析ACDeviceControl函数，发现当IoControl调用号为0x19658107且输出缓冲区的总长度为0x2C0时，它会进一步调用ACSendMessage这一派发函数。ACSendMessage函数首先将用户态缓冲区复制到内核态栈上的缓冲区，之后，将执行核心的业务逻辑，调用 CQueue::PutNewPacket来发送用户请求的数据，完成后再调用 ACFreeDeepCopyQueueFormat进行堆内存的释放。此处便存在漏洞：进行内存释放操作传入的第二个参数直接读取自用户态缓冲区中。如图8所示，参数a4就是指向缓冲区的指针。</p><p> <img loading="lazy" src="/assets/images/b485e0c2-cb7a-4903-91ba-6af3bc701754-20ce7ffc82824bb81171d9b80bca7d3a.png" width="1562" height="840" class="img_ev3q"></p><p><em>图8：漏洞函数重复读取了用户输入</em></p><p>这意味着，如果恶意攻击者设法赢得竞态条件，在ACSendMessage函数进行内存释放前成功地修改了此处的参数值，将其设置为较大的值，那么将导致超出范围地释放任意指针。</p><p>经过进一步分析，触发漏洞时消息队列虚拟设备需要处于特定的状态，这需要PoC程序预先执行其它的IoControl调用。同时，用户缓冲区中偏移量584个字节处应当是一个合法的指针，才能通过消息队列驱动程序的参数检查。在满足这些约束条件的情形下，PoC程序启动两个线程，一个用于发送IoControl调用，另一个则修改用户缓冲区中偏移量592个字节处的值为较大值。通过人工构造参数并编写PoC程序发起IoControl请求，可以成功地使内核崩溃，如图9、图10所示。</p><p> <img loading="lazy" src="/assets/images/4d97120f-d70c-474a-a987-f154eb51be9c-bff66130906a7c5e77a28c3c6dbe7329.png" width="1269" height="1081" class="img_ev3q"></p><p><em>图9：漏洞导致蓝屏，原因为BAD_POOL_CALLER</em></p><p> <img loading="lazy" src="/assets/images/6b6ab504-db0a-42e8-bbf3-3748c5c706b5-61a2db8cd1011a251a731f0839276522.png" width="1270" height="759" class="img_ev3q"></p><p><em>图10：WinDbg观察触发漏洞的调用栈，与预期的相同</em></p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="四漏洞总结">四、漏洞总结<a href="#四漏洞总结" class="hash-link" aria-label="四、漏洞总结的直接链接" title="四、漏洞总结的直接链接">​</a></h2><p>在本章中，笔者将概括Windows内核竞态条件漏洞的一些模式，并说明对漏洞的分析如何指导模糊测试方法或者开展相关的研究工作。</p><p>在研究中观察到，这些竞态条件漏洞的发现的时间范围从2018年至2023年，系统版本跨越Windows 7至Windows 11。其中，消息队列驱动程序中的漏洞，已经存在超过10年的时间才被发现。该驱动程序是Windows的可选功能，默认并未开启，可以推测此前的很长时间内也没有被安全研究人员所注意。事实上，Windows系统中存在大量的老旧代码，它们可能并未经过充分的测试，因此包含潜在的安全漏洞。</p><p>发现漏洞所处的模块也具有多样性。除去Windows内核ntoskrnl.exe外，还有相当部分的漏洞存在于Windows的图形子系统和内核驱动程序中。触发这些漏洞的方法也各不相同，包括ntoskrnl系统调用、win32系统调用和IoControl调用等。</p><p>根据对驱动程序中所存在的竞态条件漏洞的观察，它们往往可以通过多线程同时发起IoControl调用来触发，但IoControl的参数必须通过严格的检查才能使驱动程序的控制流到达漏洞点。特别地，对CVE-2023-21537漏洞的研究体现出，通过人工方法来触发漏洞需要大量的专家知识，并且构造参数、调试PoC程序的效率较低。这意味着，如果要开展自动化模糊测试，必须通过静态分析或符号执行等方式从驱动程序中提取信息，才能对巨大的输入参数空间进行划分，提高测试的效率。否则，模糊测试可能无法到达更深层的代码逻辑中，效果上也将无法达到人工漏洞挖掘的效果。</p><p>此外，研究中还发现，具体漏洞类型主要包括UAF、OOB和Double fetch这三类。其中，UAF漏洞数量较多。对于竞态条件导致的UAF漏洞，往往需要在特定的时间窗口内触发，因此即使执行了漏洞代码，也不一定能够直接产生崩溃。在实际的测试中，PoC程序也往往需要运行约数秒到数十秒的时间才能赢得竞态条件。因此，要自动化地挖掘此类漏洞，必须对内核态的内存访问违例行为进行监测，也即为模糊测试器部署对应的Sanitizer。</p><p>由于竞态条件漏洞的出现伴随着线程交错的随机性，其相比于通过顺序的系统调用序列来测试内核更为复杂。目前学术界对内核竞态条件漏洞挖掘的研究往往针对Linux等开源操作系统，而在Windows这一闭源目标上，还没有诞生成熟的竞态条件漏洞挖掘工具。</p><p>总而言之，对Windows内核竞态条件漏洞的挖掘仍有很多值得探索的方向，期待未来能在学术界和工业界看到更多的创新成果，希望本文能起到抛砖引玉的效果。</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="五作者介绍">五、作者介绍<a href="#五作者介绍" class="hash-link" aria-label="五、作者介绍的直接链接" title="五、作者介绍的直接链接">​</a></h2><p>ID：米米</p><p>个人介绍：天工实验室实习生；现就读于清华大学网络研究院，从事 Windows 内核漏洞挖掘研究。</p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/microsoft">Microsoft</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/windows">Windows</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/race-condition">Race Condition</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><meta itemprop="description" content="一、漏洞描述"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/microsoft-hyper-vtpm">Microsoft Hyper-V 虚拟 TPM 设备漏洞分析</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-10-25T00:00:00.000Z" itemprop="datePublished">2023年10月25日</time> · <!-- -->阅读需 8 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><span itemprop="name">洪祯皓</span></div><small class="avatar__subtitle" itemprop="description">安全研究员 @奇安信-天工实验室</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="一漏洞描述">一、漏洞描述<a href="#一漏洞描述" class="hash-link" aria-label="一、漏洞描述的直接链接" title="一、漏洞描述的直接链接">​</a></h2><p>2023年10月微软发布的安全更新中，修复了2个由笔者报送的Hyper-V虚拟TPM设备漏洞。本次修复的Hyper-V虚拟TPM组件的漏洞可以通过远程访问虚拟机的方式触发漏洞，造成宿主机拒绝服务或者远程代码执行，对宿主机上的其他虚拟机或业务造成损失。</p></div><footer class="row docusaurus-mt-lg"><div class="col col--9"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/microsoft">Microsoft</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/hyper-v">Hyper-V</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/tpm">TPM</a></li></ul></div><div class="col text--right col--3"><a aria-label="阅读 Microsoft Hyper-V 虚拟 TPM 设备漏洞分析 的全文" href="/blog/microsoft-hyper-vtpm"><b>阅读更多</b></a></div></footer></article><nav class="pagination-nav" aria-label="博文列表分页导航"></nav></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">文档</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/quickstart">教程</a></li><li class="footer__item"><a class="footer__link-item" href="/blog">博客</a></li></ul></div><div class="col footer__col"><div class="footer__title">联系我们</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://www.qianxin.com/" target="_blank" rel="noopener noreferrer" class="footer__link-item">奇安信<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://research.qianxin.com/" target="_blank" rel="noopener noreferrer" class="footer__link-item">奇安信技术研究院<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://poc.qianxin.com/" target="_blank" rel="noopener noreferrer" class="footer__link-item">破壳平台<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">更多</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/TianGongLab" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2014-2023 奇安信集团. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.0118f860.js"></script>
<script src="/assets/js/main.f99e6d73.js"></script>
</body>
</html>