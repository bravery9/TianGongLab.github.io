<!doctype html>
<html lang="zh-Hans" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.3">
<title data-rh="true">Datacon 2023 漏洞分析赛道赛题二官方题解 | 破壳漏洞挖掘平台文档系统</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://poc.qianxin.com/img/poc-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://poc.qianxin.com/img/poc-social-card.jpg"><meta data-rh="true" property="og:url" content="https://poc.qianxin.com/blog/tiangongarticle008"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="Datacon 2023 漏洞分析赛道赛题二官方题解 | 破壳漏洞挖掘平台文档系统"><meta data-rh="true" name="description" content="0x00 前言"><meta data-rh="true" property="og:description" content="0x00 前言"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2023-11-30T00:00:00.000Z"><meta data-rh="true" property="article:tag" content="Datacon,Static Analysis"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://poc.qianxin.com/blog/tiangongarticle008"><link data-rh="true" rel="alternate" href="https://poc.qianxin.com/blog/tiangongarticle008" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://poc.qianxin.com/blog/tiangongarticle008" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://M80RFF4T9F-dsn.algolia.net" crossorigin="anonymous"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="破壳漏洞挖掘平台文档系统 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="破壳漏洞挖掘平台文档系统 Atom Feed">



<link rel="search" type="application/opensearchdescription+xml" title="破壳漏洞挖掘平台文档系统" href="/opensearch.xml"><link rel="stylesheet" href="/assets/css/styles.67d168ad.css">
<link rel="preload" href="/assets/js/runtime~main.6420e639.js" as="script">
<link rel="preload" href="/assets/js/main.ecfcdf69.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top navbarHideable_m1mJ"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a href="https://poc.qianxin.com" target="_blank" rel="noopener noreferrer" class="navbar__brand"><div class="navbar__logo"><img src="/img/logo.svg" alt="破壳文档" class="themedImage_ToTc themedImage--light_HNdA nav-logo-class" height="20" width="100"><img src="/img/logo.svg" alt="破壳文档" class="themedImage_ToTc themedImage--dark_i4oU nav-logo-class" height="20" width="100"></div><b class="navbar__title text--truncate"></b></a><a class="navbar__item navbar__link tutorialClass" href="/">文档</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">博客</a></div><div class="navbar__items navbar__items--right"><div class="searchBox_ZlJk"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索</span></span><span class="DocSearch-Button-Keys"></span></button></div><a href="https://poc.qianxin.com/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">破壳官网<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_pO2u margin-bottom--md">所有文章</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/blog/tiangongarticle008">Datacon 2023 漏洞分析赛道赛题二官方题解</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/tiangongarticle007">IoT 设备中的认证绕过漏洞分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/tiangongarticle006">Exchange Server(CVE-2023-36439)远程代码执行漏洞分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/tiangongarticle005">WAF防护绕过技巧分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/tiangongarticle004">伪随机数问题浅析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/tiangongarticle003">Windows内核竞态条件漏洞研究</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/tiangongarticle002">Microsoft Hyper-V 虚拟 TPM 设备漏洞分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/tiangongarticle001">CVE-2023-0179 Linux内核提权</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><meta itemprop="description" content="0x00 前言"><header><h1 class="title_f1Hy" itemprop="headline">Datacon 2023 漏洞分析赛道赛题二官方题解</h1><div class="container_mt6G margin-vert--md"><time datetime="2023-11-30T00:00:00.000Z" itemprop="datePublished">2023年11月30日</time> · <!-- -->阅读需 28 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><img class="avatar__photo" src="https://github.com/Wood1314.png" alt="w00d" itemprop="image"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><span itemprop="name">w00d</span></div><small class="avatar__subtitle" itemprop="description">Asuri 战队队长，信息安全铁人三项赛一等奖，Datacon 2023 出题人</small></div></div></div></div></header><div id="__blog-post-container" class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="0x00-前言">0x00 前言<a href="#0x00-前言" class="hash-link" aria-label="0x00 前言的直接链接" title="0x00 前言的直接链接">​</a></h2><p><a target="_blank" href="/assets/files/finnal-3390a0108f6c33c52557dfce05f17628.zip">赛题二附件.zip</a></p><p>​本题目来源于对<a href="https://github.com/openwrt/openwrt" target="_blank" rel="noopener noreferrer">openwrt项目源码</a>魔改。基于实战中的场景，在题目中设置了三种相对固定且常见的漏洞模式，希望选手们在对固定漏洞模式理解的基础上，可以利用静态分析工具辅助进行分析，探索各种漏洞分析工具与人工分析相结合的漏洞挖掘模式，减少一定量的重复人工审计。</p><p>​静态分析工具都有其自身的缺陷，分析的结果很难做到尽善尽美。因此站在一位漏洞挖掘工程师的角度，我设置本题的目标是探索如何合理的使用静态分析工具，并最大程度的利用这种自动化的方式帮助我们减少人工分析的工作。</p><p>这里的题解主要使用我们自研的二进制静态分析工具——破壳平台的交互式查询来辅助我们进行分析，大致来说有以下思路：</p><ol><li>根据漏洞模式的某些参数特征进行匹配</li><li>定义source点和sink点进行污点追踪</li><li>根据漏洞模式上下文特征来匹配漏洞</li></ol><p>我们将会介绍这三种思路来进行查询解题，具体漏洞的答案和查询规则在文末可见。</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="0x01-根据参数特征查询">0x01 根据参数特征查询<a href="#0x01-根据参数特征查询" class="hash-link" aria-label="0x01 根据参数特征查询的直接链接" title="0x01 根据参数特征查询的直接链接">​</a></h2><p>根据参数特征查询适用于过滤一些常见的危险函数的危险操作。</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="11-针对strcat函数">1.1 针对strcat函数<a href="#11-针对strcat函数" class="hash-link" aria-label="1.1 针对strcat函数的直接链接" title="1.1 针对strcat函数的直接链接">​</a></h3><p>例如如果strcat的二个参数是一个常量字符串的话是很难有溢出的，即使有溢出也难以造成很大的危害。故此这种情况我们一般不需重点关注。</p><p>在本次datacon赛题二中，我们对strcat进行查询并设置其第二个参数是一个变量的情况。这里我们的查询规则如下，查找类型为变量(identifier)，callee的筛选是为了筛选出调用这个变量的函数要是<code>strcat</code>函数，最后<code>index</code>指定了这个变量是strcat的第二个参数（下标从0开始)，<code>as taintPropagationPath RETURN taintPropagationPath</code> 是为了前端将结果显示的更好看一些。</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">match (n:identifier) where n.callee=&quot;strcat&quot; and n.index=1 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">with [n] as taintPropagationPath RETURN taintPropagationPath</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>查询结果如下，可以看到符合的结果只有两条。因为查询到的结果并不多，所以可以进行一下人工验证。验证后发现恰好是我们题目设置的答案<code>odhcpd:0x000036A9</code> <code>odhcpd:0x000035F9</code></p><p><img loading="lazy" alt="image-20231127111622960" src="/assets/images/1-6cce3c8e33b33dcbee5b8683fd0d95f1.png" width="1994" height="854" class="img_ev3q"></p><p>依据这种思路我们可以查询到 <strong>漏洞3</strong>，<strong>漏洞4</strong></p><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="总结">总结<a href="#总结" class="hash-link" aria-label="总结的直接链接" title="总结的直接链接">​</a></h4><p>与之类似的情况还有strcpy函数，我们依然可以依照上面的原则进行编写规则进行查询。</p><p>在现实情况中，如果我们上传了整个固件可以如此查询一下他system和popen的调用情况，那么如果他执行的是一个常量字符串那么肯定不可能是一个命令注入漏洞。因此我们可以同样对他system和popen的第一个参数类型进行限制，帮助我们初步筛选一下目标，减轻人工逆向的工作量。</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="12-针对memmove函数">1.2 针对memmove函数<a href="#12-针对memmove函数" class="hash-link" aria-label="1.2 针对memmove函数的直接链接" title="1.2 针对memmove函数的直接链接">​</a></h3><p>首先我们来看下memmove函数的函数定义，第一个参数是dst，第二个参数是src，第三个参数是len</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> void *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> memmove(void *dst, const void *src, size_t len);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>通常memmove安全的使用方法有以下两种</p><ol><li><p>调用memmove函数的时候第三个参数是一个固定的值</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">memmove(dest, src, sizeof(dest));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li><li><p>memmove的dest大小是根据第三个参数的大小申请出来的</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">dest = malloc(size);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">memmove(dst, src, size);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li></ol><p>我们针对这两种情况进行排除，编写查询命令。其中<code>not (m)-[:dfg]-(n) </code>即是现在第一个参数跟第三个参数之间不存在直接的数据流关系</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">match (n:identifier{callee:&quot;memmove&quot;,index:0}), </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(m:identifier{callee:&quot;memmove&quot;,index:2})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">where n.function=m.function and m.line=n.line </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">and not (m)-[:dfg]-(n) WITH [m] AS taintPropagationPath </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN taintPropagationPath</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>下图即是在lldpd中查询到的结果，即两个对应的答案<code>lldpd:0x0804F6EC</code>，<code>lldpd:0x0804F848 </code></p><p><img loading="lazy" alt="image-20231127152922693" src="/assets/images/2-32830dc1e037b524f47e795df97c0b24.png" width="1928" height="842" class="img_ev3q"></p><p>依据此思路我们在全部的二进制中进行搜索到接近20处疑似位置。得益于破壳平台可返回的疑似点的反编译代码我们可以人工快速判断一下，如果仍有比较多的不确定选项我们可以考虑针对这些特定的memmove使用污点查询来进行二次筛选。</p><p>最终我们可以查询到<strong>漏洞5</strong> <strong>漏洞6</strong> <strong>漏洞7</strong> <strong>漏洞9</strong> <strong>漏洞10</strong> <strong>漏洞11</strong></p><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="总结-1">总结<a href="#总结-1" class="hash-link" aria-label="总结的直接链接" title="总结的直接链接">​</a></h4><p>其实如签到题的格式化字符串，其他危险函数如snprintf等都可以用这种方法查询，且也都有不错的过滤效果</p><p>但在更多的二进制一起查的时候这种查询方法还是略显粗糙，如果出现的结果仍然很多，我们可以结合污点查询或是我们人工分析出的再编写规则进行过滤。</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="0x02-使用污点追踪">0x02 使用污点追踪<a href="#0x02-使用污点追踪" class="hash-link" aria-label="0x02 使用污点追踪的直接链接" title="0x02 使用污点追踪的直接链接">​</a></h2><p>污点追踪可以让我们聚焦数据流传播到的危险函数。</p><p>签到题，题目一，题目二所包含的漏洞类型其实都可以使用污点查询的方式来进行查询与之前提到的查询方法进行交叉验证。</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="21-使用默认source和sink">2.1 使用默认source和sink<a href="#21-使用默认source和sink" class="hash-link" aria-label="2.1 使用默认source和sink的直接链接" title="2.1 使用默认source和sink的直接链接">​</a></h3><p>针对ustpd这个目标，我们使用下面默认的source到sink的污点查询进行查找，也就是平台定义的is_source和is_sink。</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">match (n:identifier) where n.is_source=1 with collect(id(n)) as sourceSet </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">match (m:identifier{index:0}) where m.is_sink=1 with sourceSet,collect(id(m)) as sinkSet </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CALL VQL.taintPropagation(sourceSet, sinkSet,1) YIELD taintPropagationPath </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN taintPropagationPath ORDER BY size(taintPropagationPath)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如下，我们成功查询到了签到题的格式化字符串漏洞<code>ustpd:0x0804F571</code>，其数据流调用也很清晰。</p><p><img loading="lazy" src="/assets/images/3-32d55d893e8c87c3305486ff432a7cf0.png" width="1684" height="300" class="img_ev3q"></p><p>在赛题中其实使用标准库函数作为source点的程序比较少，因此基本没有什么误报。依据此思路我们可以查询到 <strong>漏洞1</strong> <strong>漏洞2</strong></p><p>不过显然，这比我们预期当中要查找到的漏洞点要少，我们还需要进一步对每个程序可能的source点进行分析，再对其进行自定义source点的污点追踪。有一些程序自定义的函数可能反编译工具无法准确识别他们的参数，我们也可以通过在ghidra中进行重定义后导出gzf文件，再上传到破壳平台上进行分析。</p><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="总结-2">总结<a href="#总结-2" class="hash-link" aria-label="总结的直接链接" title="总结的直接链接">​</a></h4><p>对于一些source和sink非常明确的程序，使用这种查询方法能帮助我们快速锁定一些值得审视的攻击面且能帮助我们排除调大量无威胁的危险函数调用。</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="22-使用自定义的sourcesink点">2.2 使用自定义的source，sink点<a href="#22-使用自定义的sourcesink点" class="hash-link" aria-label="2.2 使用自定义的source，sink点的直接链接" title="2.2 使用自定义的source，sink点的直接链接">​</a></h3><p>对于整数溢出漏洞，我们可以采用上面的根据参数特征来排除，或者匹配一些模式。这里笔者选择采用source点到malloc的方式来进行污点查询。因为发生整数溢出的前提也是malloc的size字段是我们可控的。</p><p>下面我们针对bfdd进行一个污点查询，其中source就设置为默认的is_source，sink设置为malloc函数。可以查询到这个漏洞即是我们设置的漏洞点<code>bfdd:0x0805AD02</code></p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">call VQL.getArgument(&quot;malloc&quot;,0) yield node with collect(id(node)) as sinkset </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">match (n:identifier) where n.is_source=1 with collect(id(n)) as sourceset,sinkset </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">call VQL.taintPropagation(sourceset,sinkset,3) yield taintPropagationPath return taintPropagationPath</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><img loading="lazy" alt="image-20231127174619798" src="/assets/images/4-6b1e27d680fc1d113e4c55be9cf87050.png" width="1458" height="332" class="img_ev3q"></p><p>当然很多情况下，程序由于间接的函数调用，或是程序存在身自定义的数据读取函数。这时使用默认的source点可能就会没有结果。这时我们需要对程序简单的进行分析，例如uhtppd其实是使用<code>ustream_get_read_buf</code>这个函数返回一个包含着网络通信数据的buffer地址。我们就可以将<code>ustream_get_read_buf</code>这个函数的返回值作为一个source点。</p><p>在题目中存在少量查到数据流但是并非是漏洞点的情况，但是数量不多且破壳平台返回了详细的污点追踪路径情况，因此很容易排除掉。最后依据此思路可以查询  <strong>漏洞8</strong> <strong>漏洞12</strong> <strong>漏洞13</strong> <strong>漏洞14</strong></p><p>在实际情况中如果我们遇到了某个数据流中有明显的check点导致后续的危险函数调用是安全的，我也可以通过写对应的规则去排除这种情况。</p><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="总结-3">总结<a href="#总结-3" class="hash-link" aria-label="总结的直接链接" title="总结的直接链接">​</a></h4><p>适用于对程序进行了一定分析后，自动化寻找一些自己感兴趣的数据流。基于这些数据流进行分析，即使在没有符号执行的条件下也是可以大大减轻我们分析的工作量的。</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="0x03根据漏洞上下文查询">0x03根据漏洞上下文查询<a href="#0x03根据漏洞上下文查询" class="hash-link" aria-label="0x03根据漏洞上下文查询的直接链接" title="0x03根据漏洞上下文查询的直接链接">​</a></h2><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="31-根据函数名判断函数功能">3.1 根据函数名判断函数功能<a href="#31-根据函数名判断函数功能" class="hash-link" aria-label="3.1 根据函数名判断函数功能的直接链接" title="3.1 根据函数名判断函数功能的直接链接">​</a></h3><p>而对于类似于第三题这种实现为循环拷贝的转码函数，一种思路是我们可以从函数名的角度入手，利用下面的正则匹配匹配出具有类似编码功能的函数</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (n:function)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE n.name =~ &quot;.*decode.*|.*hex.*&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN n.name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LIMIT 1000</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>以下四个漏洞均可使用这种思路查出</p><p><strong>漏洞16</strong> <strong>漏洞17</strong> <strong>漏洞18</strong> <strong>漏洞19</strong></p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="32-根据函数结构判断函数功能">3.2 根据函数结构判断函数功能<a href="#32-根据函数结构判断函数功能" class="hash-link" aria-label="3.2 根据函数结构判断函数功能的直接链接" title="3.2 根据函数结构判断函数功能的直接链接">​</a></h3><p>寻找到一个成环的<code>cfg（control flow graph)</code>，这部分成环的<code>cfg</code>一般都是一个循环操作。然后我们再观察该循环操作所对应的<code>code_line(对应的反编译代码）</code>中是否有我们关心的操作。如对于该函数传入的参数<code>param_2</code>的赋值操作。这个语句也可以考虑写的更精确一些，比如成环中间经过的所有basic_block都可以判断下其所属的<code>code_line</code>中有无我们关心的操作。</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">match (m:code_line)&lt;-[:own]-(n:basic_block)-[:cfg*1..3]-&gt;(n) where m.name contains &quot;*param_2&quot;  return DISTINCT n.function limit 1000</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><img loading="lazy" alt="image-20231128095721975" src="/assets/images/5-24b21e6cf49ffb07c46a508cbdc09b14.png" width="1706" height="690" class="img_ev3q"></p><p>依据此思路可以查询到 <strong>漏洞20</strong>，但我们可以看到上面的查询方法查找到符合这种定义的函数有48个。这时候依据题目给出的提示<code>寻找解码类型的函数</code>。这里查询到的很多函数明显从名称上来看就可以判断不是我们需要关注的。故此我们可以通过再编写规则这些函数所在的文件，这个函数的名称，调用这个函数处的参数类型进行筛选。</p><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="总结-4">总结<a href="#总结-4" class="hash-link" aria-label="总结的直接链接" title="总结的直接链接">​</a></h4><p>利用破壳平台还可以根据程序的一些<code>basic_block</code>的结构信息，<code>ast</code>的相关信息等进行查询。有一些通过参数类型，数据流不好识别的漏洞模式特征通过基本块或者语法树的特征可能更容易识别到。</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="0x04-写在最后">0x04 写在最后<a href="#0x04-写在最后" class="hash-link" aria-label="0x04 写在最后的直接链接" title="0x04 写在最后的直接链接">​</a></h2><p>破壳平台在设计之初就一直在思考怎么让漏洞挖掘工程师和静态分析工具进行更高效的人机结合，我们考虑到常用的漏洞扫描工具很难将使用者对特定目标的经验加入进去，所以使用了查询交互式漏洞挖掘的思路，用户可以不断地编程来搜索漏洞、逼近漏洞，沉淀出针对某些漏洞的“专属”规则，甚至实现批量扫描；同时我们在日常工作中还深刻认识到漏洞挖掘有时候以团队的形式开展可以更高效，所以我们依托查询交互式漏洞挖掘这种模式，让用户和小伙伴们可以“开黑”挖洞。</p><p>当然，破壳平台目前还有很多不足，例如漏洞查询语言当前门槛和学习成本较高、UI还不够美观、平台容易崩等情况，在接收到反馈后我们也制定了开发计划，将一步步的完善；我们也计划放出更多的案例文档来帮助大家学习，向大家展示平台更多的用法，希望大家可以和破壳平台一起成长。</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="0x05-题目答案">0x05 题目答案<a href="#0x05-题目答案" class="hash-link" aria-label="0x05 题目答案的直接链接" title="0x05 题目答案的直接链接">​</a></h2><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="漏洞1">漏洞1<a href="#漏洞1" class="hash-link" aria-label="漏洞1的直接链接" title="漏洞1的直接链接">​</a></h3><p>从<code>recvfrom</code>函数接收到的数据直接作为<code>printf</code>函数的格式化字符串参数使用</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">cc = recvfrom(ufd.fd, &amp;buf, sizeof(buf), 0, (struct sockaddr *)&amp;sl, &amp;salen);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (cc &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            switch (errno)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            case EINTR:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            case EAGAIN:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            default:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                cc = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        snprintf(log_buf, sizeof(log_buf), &quot;recvfrom recved : %s&quot;, buf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(log_buf);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>简单送分格式化字符串，可以根据题目提示设置source点与sink点进行污点查询</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (n:identifier) WHERE n.callee = &quot;recvfrom&quot; AND n.index=1 WITH collect(id(n)) as sourceSet</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (n:identifier) WHERE n.callee = &quot;printf&quot; AND n.index=0 WITH sourceSet,collect(id(n)) as sinkSet </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">call VQL.taintPropagation(sourceSet,sinkSet,3)YIELD taintPropagationPath RETURN taintPropagationPath</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>ustpd:0x0804F571</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="漏洞2">漏洞2<a href="#漏洞2" class="hash-link" aria-label="漏洞2的直接链接" title="漏洞2的直接链接">​</a></h3><p>漏洞附件为ustp</p><p>在ustp附件中的bridge_bpdu_rcv函数中，会调用如下代码，其中snprintf的第二个参数是可控的，这样把h拷贝到paket上时会造成缓冲区溢出，</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">char packet[1300];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    snprintf(packet, l, &quot;LLC header and the data %s&quot;, h);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    LOG(&quot;header len %d, data %s&quot;, l, packet);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>使用<code>recvfrom</code>函数的<code>buffer</code>参数作为<code>source</code>点，<code>snprintf</code>的<code>size</code>参数作为<code>sink</code>点进行污点传播</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (n:identifier) WHERE n.callee = &quot;recvfrom&quot; AND n.index=1 WITH collect(id(n)) as sourceSet </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (n:identifier) WHERE n.callee = &quot;snprintf&quot; AND n.index=1 WITH sourceSet,collect(id(n)) as sinkSet </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">call VQL.taintPropagation(sourceSet,sinkSet,3)YIELD taintPropagationPath </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN taintPropagationPath</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>ustpd:0x0804F79B </p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="漏洞3">漏洞3<a href="#漏洞3" class="hash-link" aria-label="漏洞3的直接链接" title="漏洞3的直接链接">​</a></h3><p>漏洞附件为odhcpd</p><p>odhcpd_receive_packets在解包过程中存在缓冲区溢出漏洞。由strcat造成</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">char buf[32];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">snprintf(buf, 0x20u, &quot;Received %zd Bytes from &quot;, len);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">strcat(buf, ipbuf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">syslog(7, &quot;%s&quot;, buf);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这个和下面的漏洞3可以是同一思路，因为这几个二进制中使用<code>strcat</code>函数的地方一共也没有几处，因此直接对危险函数<code>strcat</code>查询即可</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">match (n:identifier) where n.callee=&quot;strcat&quot; and n.index=1  return n</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>odhcpd:0x000035F9</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="漏洞4">漏洞4<a href="#漏洞4" class="hash-link" aria-label="漏洞4的直接链接" title="漏洞4的直接链接">​</a></h3><p>附件odhcpd</p><p>同样是strcat造成的漏洞</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">if ( destiface )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      for ( i = interfaces.list_head.next; i-&gt;prev != interfaces.list_head.prev; i = i-&gt;next )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if ( i[4].next == (list_head *)destiface )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          snprintf(buf, 0x20u, &quot;Received %zd Bytes from &quot;, len);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          strcat(buf, ipbuf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          syslog(7, &quot;%s&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          ((void (__cdecl *)(odhcpd_receive_packets::$54E5DB5725EA5BD631F9B1F8B1B758E1 *, uint8_t *, int, list_head *, void *))u[1].cb)(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &amp;addr,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            data_buf,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            len,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            i,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            dest);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>查找危险函数就可以筛选出</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">match (n:identifier) where n.callee=&quot;strcat&quot; and n.index=1  return n</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>odhcpd:0x000036A9</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="漏洞5">漏洞5<a href="#漏洞5" class="hash-link" aria-label="漏洞5的直接链接" title="漏洞5的直接链接">​</a></h3><p>附件为bgpd</p><p>在bgp_flowspec_ip_address函数中psize是用户可控的，这个值没有检查就被传入给了memcpy的第三个参数造成了缓冲区溢出</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">prefix_local.prefixlen = nlri_ptr[offset];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    psize = PSIZE(prefix_local.prefixlen);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    offset++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    prefix_local.family = afi2family(afi);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (prefix_local.family == AF_INET6) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        prefix_offset = nlri_ptr[offset];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ipv6_offset)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            *ipv6_offset = prefix_offset;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        offset++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memmove(&amp;prefix_local.u.prefix, &amp;nlri_ptr[offset], psize);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>寻找第一个参数和第三个参数之间没有dfg(data flow graph)数据流关系的memmove函数调用。这种查询思路一个是排除了第三个参数为常数的情况，一个是排除了下面这种情况:</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">buf = malloc(n+1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">memmove(buf, data, n);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>以下是查询语句</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">match (n:identifier{callee:&quot;memmove&quot;,index:0}), (m:identifier{callee:&quot;memmove&quot;,index:2})where n.function=m.function and m.line=n.line and not (m)-[:dfg]-(n) return m.function,m.file</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>bgpd:0x8146C95</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="漏洞6">漏洞6<a href="#漏洞6" class="hash-link" aria-label="漏洞6的直接链接" title="漏洞6的直接链接">​</a></h3><p>附件为bgpd</p><p>在bgp_capability_parse中memmove的第三个参数来自于用户可控的数据，但是并没有对其大小做限制</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">switch (caphdr.code) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        case CAPABILITY_CODE_MP: {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            *mp_capability = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            /* Ignore capability when override-capability is set. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!CHECK_FLAG(peer-&gt;flags,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    PEER_FLAG_OVERRIDE_CAPABILITY)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                /* Set negotiated value. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ret = bgp_capability_mp(peer, &amp;caphdr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                /* Unsupported Capability. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (ret &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    /* Store return data. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    char tmp_buf[0x30];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    memmove(tmp_buf, sp, caphdr.length + 2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    strcpy(*error, tmp_buf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    *error += caphdr.length + 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ret = 0; /* Don&#x27;t return error for this */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } break;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>寻找第一个参数和第三个参数之间没有数据流关系的memmove函数调用</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">match (n:identifier{callee:&quot;memmove&quot;,index:0}), (m:identifier{callee:&quot;memmove&quot;,index:2})where n.function=m.function and m.line=n.line and not (m)-[:dfg]-(n) return m.function,m.file</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>bgpd:0x08149FE1</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="漏洞7">漏洞7<a href="#漏洞7" class="hash-link" aria-label="漏洞7的直接链接" title="漏洞7的直接链接">​</a></h3><p>附件为bgp</p><p>在bgp_route_refresh_receive函数中，pize来自于用户数据后续没有进行范围检测即传入了memmove第三个参数中</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">if ((ok = (p_pnt &lt; p_end)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        orfp.p.prefixlen = *p_pnt++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    /* afi checked already */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    orfp.p.family = afi2family(afi);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    /* 0 if not ok */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    psize = PSIZE(orfp.p.prefixlen);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (psize &gt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        memmove(&amp;orfp.p.u.prefix, p_pnt,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                               psize);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>寻找第一个参数和第三个参数之间没有数据流关系的memmove函数调用</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">match (n:identifier{callee:&quot;memmove&quot;,index:0}), (m:identifier{callee:&quot;memmove&quot;,index:2})where n.function=m.function and m.line=n.line and not (m)-[:dfg]-(n) return m.function,m.file</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>bgpd:0x08144EE0</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="漏洞8">漏洞8<a href="#漏洞8" class="hash-link" aria-label="漏洞8的直接链接" title="漏洞8的直接链接">​</a></h3><p>在relay_process_headers中snprintf的第二个参数可控，也就是size字段可控，可以造成溢出</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">newline = strchr(buf, &#x27;\n&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!newline)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        line_len = newline + 1 - buf;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        snprintf(log_buf, line_len, &quot;%s&quot;, newline);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(&quot;%s&quot;, log_buf);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这里使用通常的污点追踪即可查询，我们可以通过一些自动化手段或人工判断出<code>uhttpd</code>文件中常用的<code>source</code>包含了<code>ustream_get_read_buf</code>等函数。</p><p>因此我们可以设置<code>ustream_get_read_buf</code>的返回值为source点，<code>snprintf</code>的第二个参数进行污点查询</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (n:identifier) WHERE n.callee = &quot;ustream_get_read_buf&quot; AND n.index=-1 WITH collect(id(n)) as sourceSet </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (n:identifier) WHERE n.callee = &quot;snprintf&quot; AND n.index=1 WITH sourceSet,collect(id(n)) as sinkSet </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CALL VQL.taintPropagation(sourceSet,sinkSet,3)YIELD taintPropagationPath </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN taintPropagationPath</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>uhttpd:0x0805108A</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="漏洞9">漏洞9<a href="#漏洞9" class="hash-link" aria-label="漏洞9的直接链接" title="漏洞9的直接链接">​</a></h3><p>附件为ldpd</p><p>在session_get_pdu中dlen是可控的，dlen的长度会超过avf的长度造成memmove越界。</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static ssize_t session_get_pdu(struct ibuf_read *r, char **b)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct ldp_hdr l;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    size_t av, dlen, left;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    av = r-&gt;wpos;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (av &lt; sizeof(l))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return (0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memcpy(&amp;l, r-&gt;buf, sizeof(l));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dlen = ntohs(l.length) + LDP_HDR_DEAD_LEN;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if ((*b = malloc(dlen)) == NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return (-1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memcpy(*b, r-&gt;buf, dlen);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    left = av - dlen;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memmove(r-&gt;buf, r-&gt;buf + dlen, left);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    r-&gt;wpos = left;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return (dlen);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>寻找第一个参数和第三个参数之间没有数据流关系的memmove函数调用</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">match (n:identifier{callee:&quot;memmove&quot;,index:0}), (m:identifier{callee:&quot;memmove&quot;,index:2})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">where n.function=m.function and m.line=n.line and not (m)-[:dfg]-(n) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">return m.function,m.file</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>ldpd:0x080671A8</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="漏洞10">漏洞10<a href="#漏洞10" class="hash-link" aria-label="漏洞10的直接链接" title="漏洞10的直接链接">​</a></h3><p>附件lldpd</p><p>在函数lldp_decode中，没有检测tlv_size是不是为0，后续在PEEK_BYTES造成缓冲区溢出</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                log_warn(&quot;lldp&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         &quot;unable to allocate memory for id tlv &quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         &quot;received on %s&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         hardware-&gt;h_ifname);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                goto malformed;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            memmove(b, pos, tlv_size - 1);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>寻找第一个参数和第三个参数之间没有数据流关系的memmove函数调用</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">match (n:identifier{callee:&quot;memmove&quot;,index:0}), (m:identifier{callee:&quot;memmove&quot;,index:2})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">where n.function=m.function and m.line=n.line and not (m)-[:dfg]-(n) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">return m.function,m.file</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>lldpd:0x0804F6EC</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="漏洞11">漏洞11<a href="#漏洞11" class="hash-link" aria-label="漏洞11的直接链接" title="漏洞11的直接链接">​</a></h3><p>附件lldpd </p><p>同样是在函数lldp_decode中，不过是另一个case，没有检测tlv_size是不是为0，后续在PEEK_BYTES造成缓冲区溢出</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                log_warn(&quot;lldp&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         &quot;unable to allocate memory for string tlv &quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         &quot;received on %s&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         hardware-&gt;h_ifname);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                goto malformed;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            memmove(b, pos, tlv_size - 1);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>寻找第一个参数和第三个参数之间没有数据流关系的memmove函数调用</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">match (n:identifier{callee:&quot;memmove&quot;,index:0}), (m:identifier{callee:&quot;memmove&quot;,index:2})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">where n.function=m.function and m.line=n.line and not (m)-[:dfg]-(n) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">return m.function,m.file</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>lldpd:0x0804F848 </p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="漏洞12">漏洞12<a href="#漏洞12" class="hash-link" aria-label="漏洞12的直接链接" title="漏洞12的直接链接">​</a></h3><p>附件bgpd </p><p>在函数bgp_notify_receive中，tmp_size是16位的数据，进行左移会造成整数溢出。后续malloc的大小会远小于memcpy的数据，最终溢出。</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">tmp_size = outer.length &lt;&lt; 3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (inner.length) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        peer-&gt;notify.length = inner.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        peer-&gt;notify.data = malloc(tmp_size);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        memcpy(peer-&gt;notify.data, inner.raw_data, inner.length);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在bgpd中，通过人工或AI方法可以分析得知<code>stream_getw</code>，<code>stream_getc</code>等函数均可以作为source点。此时我们可以使用<code>stream_getw</code>函数为的返回值为source点，<code>malloc</code>函数的第一个参数为sink点进行污点查询</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (n:identifier) WHERE n.callee = &quot;stream_getw&quot; AND n.index=-1 WITH collect(id(n)) as sourceSet </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (n:identifier) WHERE n.callee = &quot;malloc&quot; AND n.index=0 WITH sourceSet,collect(id(n)) as sinkSet </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">call VQL.taintPropagation(sourceSet,sinkSet,2)YIELD taintPropagationPath RETURN taintPropagationPath</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>bgpd:0x081443F6 </p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="漏洞13">漏洞13<a href="#漏洞13" class="hash-link" aria-label="漏洞13的直接链接" title="漏洞13的直接链接">​</a></h3><p>附件bgpd </p><p>同上，在函数bgp_notify_receive中，tmp_size是16位的数据，进行右移会造成整数溢出。后续malloc的大小会远小于memcpy的数据，最终溢出。</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/* For further diagnostic record returned Data. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (inner.length) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        peer-&gt;notify.length = inner.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        peer-&gt;notify.data = malloc(tmp_size);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        memcpy(peer-&gt;notify.data, inner.raw_data, inner.length);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>查询思路同漏洞1</p><p>bgpd:0x081444E5</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="漏洞14">漏洞14<a href="#漏洞14" class="hash-link" aria-label="漏洞14的直接链接" title="漏洞14的直接链接">​</a></h3><p>同上，在函数bgp_notify_receive中，tmp_size是16位的数据，进行右移会造成整数溢出。后续malloc的大小会远小于memcpy的数据，最终溢出。</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    /* For debug */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int first = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        char c[4];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (inner.length) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            inner.data = malloc(tmp_size);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (i = 0; i &lt; inner.length; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (first) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    snprintf(c, sizeof(c), &quot; %02x&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         stream_getc(peer-&gt;curr));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>查询思路同漏洞1</p><p>bgpd:0x08144535</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="漏洞15">漏洞15<a href="#漏洞15" class="hash-link" aria-label="漏洞15的直接链接" title="漏洞15的直接链接">​</a></h3><p>在control_read函数中bcb_left来自于用户可控的数据，读取了四个字节，但是并没有限制其大小。后续malloc的时候会造成整数溢出</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/* Validate header fields. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    plen = ntohl(bcm.bcm_length);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> bcb-&gt;bcb_buf = malloc(sizeof(bcm) + bcb-&gt;bcb_left + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (bcb-&gt;bcb_buf == NULL) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        zlog_warn(&quot;%s: not enough memory for message size: %zu&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              __func__, bcb-&gt;bcb_left);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        control_free(bcs);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这个二进制程序中用read做source点即可</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">call VQL.getArgument(&quot;malloc&quot;,0) yield node with collect(id(node)) as sinkset</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">call VQL.getArgument(&quot;read&quot;,1) yield node with collect(id(node)) as sourceset,sinkset</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">call VQL.taintPropagation(sourceset,sinkset,3) yield taintPropagationPath return taintPropagationPath</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>bfdd:0x0805AD02</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="漏洞16">漏洞16<a href="#漏洞16" class="hash-link" aria-label="漏洞16的直接链接" title="漏洞16的直接链接">​</a></h3><p>附件:uhttpd</p><p>漏洞1存在于<code>uh_b64decode</code>，其中tmp_buf长度是有限的，但是auth的长度可能会大于tmp_buf的空间</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">char tmp_buf[0x80];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (auth &amp;&amp; !strncasecmp(auth, &quot;Basic &quot;, 6))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        auth += 6;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        uh_b64decode(tmp_buf, auth, strlen(auth));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pass = strchr(tmp_buf, &#x27;:&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (pass)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            user = tmp_buf;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            *pass++ = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>对函数名中包含decode和hex的进行查询。这里使用了正则匹配的方法。当然IDA和python脚本也可以实现类似的功能，不过在多文件等情况中使用这种图数据库查询语句是一种更为简单的平替。</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MATCH (n:function)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE n.name =~ &quot;.*decode.*|.*hex.*&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RETURN n.name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LIMIT 1000</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>uhttpd:0x08050812</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="漏洞17">漏洞17<a href="#漏洞17" class="hash-link" aria-label="漏洞17的直接链接" title="漏洞17的直接链接">​</a></h3><p>附件：uhttpd</p><p>漏洞存在于uh_path_lookup中，其在调用uh_urldecode函数时会溢出uh_buff</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    /* no query string, decode all of url */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else if (uh_urldecode(&amp;uh_buff[docroot_len],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          url, strlen(url)) &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return NULL;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>与漏洞1相同</p><p>uhttpd:0x0804E4F3</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="漏洞18">漏洞18<a href="#漏洞18" class="hash-link" aria-label="漏洞18的直接链接" title="漏洞18的直接链接">​</a></h3><p>附件：uhttpd</p><p>漏洞存在于uh_path_lookup中，其在调用uh_urldecode函数时会溢出uh_buff。</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/* urldecode component w/o query */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (pathptr &gt; url)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (uh_urldecode(&amp;uh_buff[docroot_len], url, pathptr - url) &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>同上</p><p>uhttpd:0x0804E52D</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="漏洞19">漏洞19<a href="#漏洞19" class="hash-link" aria-label="漏洞19的直接链接" title="漏洞19的直接链接">​</a></h3><p>附件： odchpd-ipv6</p><p>该漏洞存在于附件odhcp-v6中，在dhcpv6_ia_handle_IAs中调用odhcpd_hexlify，其中olen没有长度限制会造成缓冲区溢出</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">dhcpv6_for_each_option(start, end, otype, olen, odata)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (otype == DHCPV6_OPT_CLIENTID)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            clid_data = odata;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            clid_len = olen;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (olen == 14 &amp;&amp; odata[0] == 0 &amp;&amp; odata[1] == 1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                memcpy(mac, &amp;odata[8], sizeof(mac));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else if (olen == 10 &amp;&amp; odata[0] == 0 &amp;&amp; odata[1] == 3)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                memcpy(mac, &amp;odata[4], sizeof(mac));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            odhcpd_hexlify(duidbuf, odata, olen);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>同上</p><p>odchpd-ipv6:0x0000D361</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="漏洞20">漏洞20<a href="#漏洞20" class="hash-link" aria-label="漏洞20的直接链接" title="漏洞20的直接链接">​</a></h3><p>附件：sshd</p><p>在sshd附件中setproctitle函数中会调用strnvis函数，该函数实际是从v8到v9进行了拷贝，但是v8的大小是小于v9的。这个函数功能是转化不可见字符。</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">char v8[512]; // [esp+1Ch] [ebp-61Ch] BYREF</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">char v9[1024]; /</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">strvis(v8, v9, 27);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>sshd:0x0008C045</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">match (m:code_line)&lt;-[:own]-(n:basic_block)-[:cfg*1..3]-&gt;(n) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">where m.name contains &quot;*param_2&quot;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">return DISTINCT n.function</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div><footer class="row docusaurus-mt-lg blogPostFooterDetailsFull_mRVl"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/datacon">Datacon</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/static-analysis">Static Analysis</a></li></ul></div><div class="col margin-top--sm"><a href="https://github.com/TianGongLab/poc_docs/tree/main/blog/2023-11-30-Datacon2023WP/index.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="博文分页导航"><a class="pagination-nav__link pagination-nav__link--next" href="/blog/tiangongarticle007"><div class="pagination-nav__sublabel">较旧一篇</div><div class="pagination-nav__label">IoT 设备中的认证绕过漏洞分析</div></a></nav><div style="margin-top:20px"></div></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#0x00-前言" class="table-of-contents__link toc-highlight">0x00 前言</a></li><li><a href="#0x01-根据参数特征查询" class="table-of-contents__link toc-highlight">0x01 根据参数特征查询</a><ul><li><a href="#11-针对strcat函数" class="table-of-contents__link toc-highlight">1.1 针对strcat函数</a></li><li><a href="#12-针对memmove函数" class="table-of-contents__link toc-highlight">1.2 针对memmove函数</a></li></ul></li><li><a href="#0x02-使用污点追踪" class="table-of-contents__link toc-highlight">0x02 使用污点追踪</a><ul><li><a href="#21-使用默认source和sink" class="table-of-contents__link toc-highlight">2.1 使用默认source和sink</a></li><li><a href="#22-使用自定义的sourcesink点" class="table-of-contents__link toc-highlight">2.2 使用自定义的source，sink点</a></li></ul></li><li><a href="#0x03根据漏洞上下文查询" class="table-of-contents__link toc-highlight">0x03根据漏洞上下文查询</a><ul><li><a href="#31-根据函数名判断函数功能" class="table-of-contents__link toc-highlight">3.1 根据函数名判断函数功能</a></li><li><a href="#32-根据函数结构判断函数功能" class="table-of-contents__link toc-highlight">3.2 根据函数结构判断函数功能</a></li></ul></li><li><a href="#0x04-写在最后" class="table-of-contents__link toc-highlight">0x04 写在最后</a></li><li><a href="#0x05-题目答案" class="table-of-contents__link toc-highlight">0x05 题目答案</a><ul><li><a href="#漏洞1" class="table-of-contents__link toc-highlight">漏洞1</a></li><li><a href="#漏洞2" class="table-of-contents__link toc-highlight">漏洞2</a></li><li><a href="#漏洞3" class="table-of-contents__link toc-highlight">漏洞3</a></li><li><a href="#漏洞4" class="table-of-contents__link toc-highlight">漏洞4</a></li><li><a href="#漏洞5" class="table-of-contents__link toc-highlight">漏洞5</a></li><li><a href="#漏洞6" class="table-of-contents__link toc-highlight">漏洞6</a></li><li><a href="#漏洞7" class="table-of-contents__link toc-highlight">漏洞7</a></li><li><a href="#漏洞8" class="table-of-contents__link toc-highlight">漏洞8</a></li><li><a href="#漏洞9" class="table-of-contents__link toc-highlight">漏洞9</a></li><li><a href="#漏洞10" class="table-of-contents__link toc-highlight">漏洞10</a></li><li><a href="#漏洞11" class="table-of-contents__link toc-highlight">漏洞11</a></li><li><a href="#漏洞12" class="table-of-contents__link toc-highlight">漏洞12</a></li><li><a href="#漏洞13" class="table-of-contents__link toc-highlight">漏洞13</a></li><li><a href="#漏洞14" class="table-of-contents__link toc-highlight">漏洞14</a></li><li><a href="#漏洞15" class="table-of-contents__link toc-highlight">漏洞15</a></li><li><a href="#漏洞16" class="table-of-contents__link toc-highlight">漏洞16</a></li><li><a href="#漏洞17" class="table-of-contents__link toc-highlight">漏洞17</a></li><li><a href="#漏洞18" class="table-of-contents__link toc-highlight">漏洞18</a></li><li><a href="#漏洞19" class="table-of-contents__link toc-highlight">漏洞19</a></li><li><a href="#漏洞20" class="table-of-contents__link toc-highlight">漏洞20</a></li></ul></li></ul></div></div></div></div></div></div>
<script src="/assets/js/runtime~main.6420e639.js"></script>
<script src="/assets/js/main.ecfcdf69.js"></script>
</body>
</html>