<!doctype html>
<html lang="zh-Hans" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.1.1">
<title data-rh="true">Terrapin 攻击分析 | 破壳漏洞挖掘平台</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://poc.qianxin.com/img/poc-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://poc.qianxin.com/img/poc-social-card.jpg"><meta data-rh="true" property="og:url" content="https://poc.qianxin.com/blog/tiangongarticle017"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="Terrapin 攻击分析 | 破壳漏洞挖掘平台"><meta data-rh="true" name="description" content="一、Terrapin Attack 背景探讨"><meta data-rh="true" property="og:description" content="一、Terrapin Attack 背景探讨"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2024-01-31T00:00:00.000Z"><meta data-rh="true" property="article:tag" content="Terrapin,SSH"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://poc.qianxin.com/blog/tiangongarticle017"><link data-rh="true" rel="alternate" href="https://poc.qianxin.com/blog/tiangongarticle017" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://poc.qianxin.com/blog/tiangongarticle017" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://M80RFF4T9F-dsn.algolia.net" crossorigin="anonymous"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="破壳漏洞挖掘平台 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="破壳漏洞挖掘平台 Atom Feed">



<link rel="search" type="application/opensearchdescription+xml" title="破壳漏洞挖掘平台" href="/opensearch.xml">
<script src="https://www.clarity.ms/tag/k257lj4y58"></script>
<script src="https://hm.baidu.com/hm.js?bd805f6d9db85a795e91b7f0e7038239" async></script><link rel="stylesheet" href="/assets/css/styles.2596aafb.css">
<script src="/assets/js/runtime~main.41ff77e6.js" defer="defer"></script>
<script src="/assets/js/main.2e30026d.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top navbarHideable_m1mJ"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a href="https://poc.qianxin.com" target="_blank" rel="noopener noreferrer" class="navbar__brand"><div class="navbar__logo"><img src="/img/logo.svg" alt="破壳文档" class="nav-logo-class themedComponent_mlkZ themedComponent--light_NVdE" height="20" width="100"><img src="/img/logo.svg" alt="破壳文档" class="nav-logo-class themedComponent_mlkZ themedComponent--dark_xIcU" height="20" width="100"></div><b class="navbar__title text--truncate"></b></a><a class="navbar__item navbar__link tutorialClass" href="/">文档</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">博客</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/blog/tags">标签</a><a class="navbar__item navbar__link" href="/blog/archive">归档</a><div class="navbarSearchContainer_Bca1"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20" aria-hidden="true"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索</span></span><span class="DocSearch-Button-Keys"></span></button></div><a href="https://poc.qianxin.com/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">破壳官网<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_pO2u margin-bottom--md">所有文章</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/tiangongarticle023">探索 DBus 跨进程消息传递中的安全风险</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/tiangongarticle022">Windows hypervisor&amp;内核调试的几种常见/不常见方法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/tiangongarticle021">FortiGate SSLVPN CVE-2024-21762漏洞利用分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/tiangongarticle020">Ghidra脚本编写：从IR到反编译C</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/tiangongarticle019">关于Linux内核条件竞争的探讨</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/tiangongarticle018">WebAssembly安全研究总结</a></li><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/blog/tiangongarticle017">Terrapin 攻击分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/tiangongarticle016">常见 PHP 源码保护与还原</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/tiangongarticle015">Server as Client 漏洞模型</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/tiangongarticle014">破壳分析：Linksys设备多个0-day漏洞</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/tiangongarticle013">ESXi SLP漏洞复现</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/tiangongarticle012">从传统到 AI 探讨 Webshell 检测攻防对抗</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/tiangongarticle011">人与代码的桥梁-聊聊SAST</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/tiangongarticle010">BMC 漏洞实例分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/tiangongarticle009">CodeDom 漏洞模式与 SharePoint RCE</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/tiangongarticle008">Datacon 2023 漏洞分析赛道赛题二官方题解</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/tiangongarticle007">IoT 设备中的认证绕过漏洞分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/tiangongarticle006">Exchange Server(CVE-2023-36439)远程代码执行漏洞分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/tiangongarticle005">WAF防护绕过技巧分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/tiangongarticle004">伪随机数问题浅析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/tiangongarticle003">Windows内核竞态条件漏洞研究</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/tiangongarticle002">Microsoft Hyper-V 虚拟 TPM 设备漏洞分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/tiangongarticle001">CVE-2023-0179 Linux内核提权</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="https://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="一、Terrapin Attack 背景探讨"><header><h1 class="title_f1Hy" itemprop="headline">Terrapin 攻击分析</h1><div class="container_mt6G margin-vert--md"><time datetime="2024-01-31T00:00:00.000Z" itemprop="datePublished">2024年1月31日</time> · <!-- -->阅读需 29 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><img class="avatar__photo" src="https://tiangonglab.github.io/img/authors/l1nk.jpg" alt="l1nk" itemprop="image"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><span itemprop="name">l1nk</span></div><small class="avatar__subtitle" itemprop="description">Datacon 2023 出题人，主攻二进制漏洞挖掘</small></div></div></div></div></header><div id="__blog-post-container" class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="一terrapin-attack-背景探讨">一、Terrapin Attack 背景探讨<a href="#一terrapin-attack-背景探讨" class="hash-link" aria-label="一、Terrapin Attack 背景探讨的直接链接" title="一、Terrapin Attack 背景探讨的直接链接">​</a></h2>
<p>这个漏洞是由<a href="https://terrapin-attack.com/" target="_blank" rel="noopener noreferrer">这边的几个安全研究员</a>提出的漏洞 ，本文也是对这里的论文进行的一个解读。这个漏洞是一个基于MITM（Man-in-the-Middle 中间人，下文简称MITM）的攻击，这意味着，这个漏洞攻击的场景如下：</p>
<div class="language-plain codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-plain codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">+----------+      +----------+         +----------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|          &lt;------+          &lt;---------+          |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| Alice    |      |   Evil   |         |  Bob     |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|          |      |          |         |          |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|          |      |          |         |          |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|          +-----&gt;|          +---------&gt;          |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+----------+      +----------+         +----------+</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这个漏洞是针对SSH的<strong>通信完整性</strong>发起的攻击，并且攻击者不具备对于会话相关密钥信息的知识，包含但不限于：</p>
<ul>
<li>加密内容的密钥</li>
<li>MAC使用的nonce</li>
<li>IV</li>
</ul>
<p>所以这个问题不是一个简单的内存泄露或者逻辑漏洞，而是一种突破完整性的攻击。该攻击的意义在于降低了SSH的防护措施，突破了SSH的<strong>通信完整性</strong>，从而使得早先出现过的攻击能够重新被利用。</p>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="11-通信完整性定义">1.1 通信完整性定义<a href="#11-通信完整性定义" class="hash-link" aria-label="1.1 通信完整性定义的直接链接" title="1.1 通信完整性定义的直接链接">​</a></h3>
<blockquote>
<p>When a secure channel between A and B is used, the data stream received by B should be identical to the one sent by A and vice versa</p>
</blockquote>
<p>以上便是对完整性的定义，双方的通信都必须能够明确知道来自对方，这就是通信完整性。</p>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="12-如何算是对ssh发起攻击">1.2 如何算是对SSH发起攻击<a href="#12-如何算是对ssh发起攻击" class="hash-link" aria-label="1.2 如何算是对SSH发起攻击的直接链接" title="1.2 如何算是对SSH发起攻击的直接链接">​</a></h3>
<p>在讨论攻击的时候，首先要明确被攻击的目标是什么。SSH协议设计的时候是以<strong>通信完整</strong>为前提进行设计的，此时SSH通信的时候能够保证信息的完整性(integrity)，这样就意味着其具备<strong>防御MITM</strong>的能力。 所以当SSH不再具备防御<strong>MitM</strong>攻击的时候，其实就可以认为对SSH完成了攻击。实际上，Terrapin提出的漏洞模型中，需对SSH途径的路由进行控制，并且能进行Sniffer和重放，才能够满足攻击模型。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="二ssh-历史问题">二、SSH 历史问题<a href="#二ssh-历史问题" class="hash-link" aria-label="二、SSH 历史问题的直接链接" title="二、SSH 历史问题的直接链接">​</a></h2>
<p>SSH历史上出现过很多问题，其中有几个比较有趣，这边就选取这几个进行讲解：</p>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="21-ssh前置知识补充">2.1 SSH前置知识补充<a href="#21-ssh前置知识补充" class="hash-link" aria-label="2.1 SSH前置知识补充的直接链接" title="2.1 SSH前置知识补充的直接链接">​</a></h3>
<p>SSH通信的大致流程如下：</p>
<p><img decoding="async" loading="lazy" alt="SSH 通信使用的diffie-hellman" src="/assets/images/3ee68d7a-7e04-4a21-9f57-192da7d41c12-23cd49d51725d9739c57a557fe47752f.png" width="923" height="722" class="img_ev3q"></p>
<p>其中，这种通信协议被称为<strong>Binary Packet Protocol BPP</strong>，也就是<strong>二进制通信协议</strong>。并且在这里给出几个基础定义：</p>
<ul>
<li>Packet： 网络数据发送的最小单位</li>
<li>Block：加密操作的最小单位</li>
</ul>
<p>二者关系为：SSH的数据包以Packet为单位发送，每一个Packet中包含多个block。</p>
<p><img decoding="async" loading="lazy" src="/assets/images/1aef72eb-b5cd-4f71-93de-b5ae9999deea-ee166e97f60d4cb9dcbf2f4a2f9443fe.png" width="1101" height="331" class="img_ev3q"></p>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="22-cve-2008-5161-针对me的攻击介绍">2.2 CVE-2008-5161 针对M&amp;E的攻击介绍<a href="#22-cve-2008-5161-针对me的攻击介绍" class="hash-link" aria-label="2.2 CVE-2008-5161 针对M&amp;E的攻击介绍的直接链接" title="2.2 CVE-2008-5161 针对M&amp;E的攻击介绍的直接链接">​</a></h3>
<p><em>注意：这个攻击思路其实在后来被证实为可能存在一定的问题，可能只有在某些理想化状态下能够使用。不过这个攻击实在是有趣，这边介绍一下这个攻击思路。</em></p>
<p>这个漏洞是一篇发在<a href="https://ieeexplore.ieee.org/document/5207634" target="_blank" rel="noopener noreferrer">IEEE的文章</a>提出来的，这里有<a href="https://conferences.computer.org/sp/pdfs/sp/2009/oakland2009-01.pdf" target="_blank" rel="noopener noreferrer">链接</a>漏洞发生在ssh对于之前提到的<code>M&amp;E</code>实现过程中的问题，属于是协议的级别的问题。由于SSH通信过程中，通信数据会发生加密，所以SSH客户端在进行数据解析的时候前会按照Block解密，并且对数据进行一定的安全性检查。然而就是在安全检查中，形成了这个漏洞的利用点。接下来来看一下这些错误检查点：</p>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="221-ssh与出错审计">2.2.1 SSH与出错审计<a href="#221-ssh与出错审计" class="hash-link" aria-label="2.2.1 SSH与出错审计的直接链接" title="2.2.1 SSH与出错审计的直接链接">​</a></h4>
<p>整个安全检查分为好多步骤，我们着重观察以下步骤：</p>
<ol>
<li>
<p>进行长度check</p>
<div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">if</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">packet_length </span><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">+</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">4</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">||</span><span class="token plain"> packet_length </span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">256</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1024</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">buffer_dump</span><span class="token punctuation" style="color:#393A34">(</span><span class="token operator" style="color:#393A34">&amp;</span><span class="token plain">incoming_packet</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">packet_disconnect</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&quot;Bad packet length%d.&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain">packet_length</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这里的<code>packet_length</code>为从第一个数据包中解密的数据。这个检查用于防止写的过大导致的DDos问题。进行长度检测时，SSH允许的数据长度为<code>[5,256 × 1024]</code>之间。（这里注意很重要）</p>
</li>
<li>
<p>进行Block的check</p>
<div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">need </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">4</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">+</span><span class="token plain"> packet_length </span><span class="token operator" style="color:#393A34">-</span><span class="token plain"> block_size</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">if</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">need </span><span class="token operator" style="color:#393A34">%</span><span class="token plain"> block_size </span><span class="token operator" style="color:#393A34">!=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">fatal</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&quot;padding error: eed %d block %d mod %d&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> eed</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> block_size</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> need </span><span class="token operator" style="color:#393A34">%</span><span class="token plain"> block_size</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>其中<code>block_size</code>会随着我们选择的加密算法变化而变化，但是总的来说为固定值且为8的倍数。这里的need表示仍然需要接受的数据长度；如果此时的数据不是对齐的状态，则此时认为传输数据有误，此时会<strong>放弃当前通信，而不进行数据返回。</strong></p>
</li>
<li>
<p>进行MAC的check</p>
<div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">if</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token function" style="color:#d73a49">buffer_len</span><span class="token punctuation" style="color:#393A34">(</span><span class="token operator" style="color:#393A34">&amp;</span><span class="token plain">input</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain"> need </span><span class="token operator" style="color:#393A34">+</span><span class="token plain"> maclen</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">return</span><span class="token plain"> SSH_MSG_NONE</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><code>buffer_len(&amp;input)</code>表示此时接受了的数据长度，<code>maclen</code>则是在SSH协议中的<code>SSH MAC</code>中指定的一个长度，根据使用的MAC不同而变化，如 果这个Check不通过，SSH则会抛出一个叫做<code>Corrupted MAC on input.</code>的错误信息。</p>
</li>
</ol>
<p>总结一下这几个check的行为，可以得出如下的现象：</p>
<table><thead><tr><th>检查内容</th><th>检查未通过行为</th></tr></thead><tbody><tr><td>Packet Length</td><td>连接断开，并且发送一个错误信息</td></tr><tr><td>Block 是否 对齐</td><td>连接断开</td></tr><tr><td>输入长度是否过长</td><td>返回错误信息</td></tr><tr><td>检查均通过</td><td>持续等待</td></tr></tbody></table>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="23-cve-2008-5161中间人攻击">2.3 CVE-2008-5161 中间人攻击<a href="#23-cve-2008-5161中间人攻击" class="hash-link" aria-label="2.3 CVE-2008-5161 中间人攻击的直接链接" title="2.3 CVE-2008-5161 中间人攻击的直接链接">​</a></h3>
<p>现在假设我们作为攻击者，能够从中间截获数据包。此时我们做出如下的假设：</p>
<ul>
<li>K为每一个block加解密使用的key</li>
<li>Enc为加密操作，Dec为解密操作</li>
<li>L为Block Size（3ds中L=8， aes中L=16）</li>
<li>pi为第i个明文Block</li>
<li>ci为第i个密文Block</li>
</ul>
<p>对于CBC模式的加密算法，存在一系列的<code>p1,p2,...pn</code>，此时有：</p>
<p>ci = Enc(pi) xor c(i-1), i = 1,2,3..n</p>
<p>其中c0为IV，也可以是BBP 中获取的最后一个加密数据块c’n.</p>
<p>对于解密，则有：</p>
<p>pi = Dec(ci) xor c(i-1), i = 1,2,3..n</p>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="231-前14bit猜测">2.3.1 前14bit猜测<a href="#231-前14bit猜测" class="hash-link" aria-label="2.3.1 前14bit猜测的直接链接" title="2.3.1 前14bit猜测的直接链接">​</a></h4>
<p>我们假设作为<strong>攻击者</strong>，我们截获了一个加密数据包<code>c*i</code>，此时我们有如下关系：</p>
<p>p*i = c*(i-1) xor Dec(c*i)</p>
<p>假设我们把这个数据包插入到下一个Packet的开头，此时我们假  设</p>
<ul>
<li>cn 为当前连接中，上一个packet的最后一个block。这个block本来是要作为IV被使用的。</li>
</ul>
<p>那么此时的解密流程如下<code>p’1 = cn xor Dec(c*i)</code> 综合上述算式，我们能得到</p>
<p>由于我们为中间人，因此可以假设我们能获取所有的ci。假设当我们插入数据包之后，出现如下的状态：</p>
<ul>
<li>状态一：SSH突然终止，没有出现任何错误信息</li>
<li>状态二：SSH开始等待更多的数据输入</li>
</ul>
<p>这均说明，程序已经通过了前文提到的<strong>长度检测</strong>。也就是说，p’1的长度范围符合要求，也就是<strong>前14bit的数据一定为0</strong>。那么根据 <code>p*i = c*(i-1) xor p’1 xor cn</code> 就能获得当前的某个<code>p*i</code>的前14bit。</p>
<p>Q：怎么找到下一个连接开头呢？</p>
<p>A：虽然没办法直接观察到Packet开头，但是可以通过观察数据通过的情况来判断什么时候有新的Packet进来。</p>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="232-所有bit恢复">2.3.2 所有bit恢复<a href="#232-所有bit恢复" class="hash-link" aria-label="2.3.2 所有bit恢复的直接链接" title="2.3.2 所有bit恢复的直接链接">​</a></h4>
<p>假设我们通过<strong>block长度check</strong>，也就是进入上述的状态二，那么此时会持续的接受block，直到下面的判断不满足要求：</p>
<div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">if</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token function" style="color:#d73a49">buffer_len</span><span class="token punctuation" style="color:#393A34">(</span><span class="token operator" style="color:#393A34">&amp;</span><span class="token plain">input</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain"> need </span><span class="token operator" style="color:#393A34">+</span><span class="token plain"> maclen</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">return</span><span class="token plain"> SSH_MSG_NONE</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>那么此时，我们就持续不断的插入<code>[1,maclen]</code>个数的$L$长的blocks，观察ssh 触发MAC错误的那一刻。此时我们就能够根据我们发送的数据包，算出这个<code>need</code>的准确值。此时，这个$p&#x27;_1$的完整值我们就能由这个公式得到：</p>
<div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">need </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">4</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">+</span><span class="token plain"> packet_length </span><span class="token operator" style="color:#393A34">-</span><span class="token plain"> block_size</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>此时，根据 上文推到的 <code>p*i = c*(i-1) xor p’1 xor cn</code> 我们就能获得所有的明文信息！ 根据总结，满足如下加密算法的传输都能够被这种方式进行攻击：</p>
<ul>
<li>加密数据包中使用了长度字段</li>
<li>使用CBC的加密模式</li>
<li>允许攻击者少量传输数据</li>
<li>在不同的数据包错误下，返回不同的错误信息</li>
</ul>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="233-攻击场景">2.3.3 攻击场景<a href="#233-攻击场景" class="hash-link" aria-label="2.3.3 攻击场景的直接链接" title="2.3.3 攻击场景的直接链接">​</a></h4>
<p>实际上，SSH也不可能允许一个用户反复的执行上述操作，其必将导致连接中断。但是，我们可以根据某些<strong>已知位置</strong>的数据进行攻击。例如，用户在进行远程登陆的时候，我们  只需要将ssh通信过程中登录密钥相关逻辑进行破译，并不需要获取整个ssh通信数据。</p>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="24-侧信道攻击-keystroke-timing-attack">2.4 侧信道攻击 keystroke timing attack<a href="#24-侧信道攻击-keystroke-timing-attack" class="hash-link" aria-label="2.4 侧信道攻击 keystroke timing attack的直接链接" title="2.4 侧信道攻击 keystroke timing attack的直接链接">​</a></h3>
<p>这个攻击其实比较神奇，这也是来自一篇<a href="https://www.usenix.org/conference/10th-usenix-security-symposium/timing-analysis-keystrokes-and-timing-attacks-ssh" target="_blank" rel="noopener noreferrer">USENIX的论文</a>。论文提到说，人们在敲击键盘的时候，会有一定的倾向性。某些特定的字符或者字符组合敲击的时候，时间间隔可能会变得很长或者很短。</p>
<p><img decoding="async" loading="lazy" src="/assets/images/c19ceb16-9e0e-421a-ae2b-cde349812d97-2a545a69401d810f6803d1714e2fd268.png" width="1017" height="397" class="img_ev3q"></p>
<p>那么，通过观察数据包的特定格式，就能够猜测此时的输入内容。如上图，通过传输数据的长度特征，能推断出是否是正在输入<code>SU</code>指令，以及猜测当前用户的输入长度。有些时候还能够通过一些特殊的观察看到额外的值。这边<a href="https://jfrog.com/blog/ssh-protocol-flaw-terrapin-attack-cve-2023-48795-all-you-need-to-know/" target="_blank" rel="noopener noreferrer">贴出一个</a>分析Terrapin-Attack的博客，这其中提到了在未提供防护的情况下，SSH数据包的特征：</p>
<p><img decoding="async" loading="lazy" src="/assets/images/c49f1a8f-8c28-4ab9-bb1b-92cc61f536d5-e24130f24657445f45cbf0dae4efcfcd.png" width="1146" height="472" class="img_ev3q"></p>
<p>可以看到，在未使用防护技巧的时候，SSH的数据包时间间隔和数据大小是有明显差异的，而在SSH修复的场景中：</p>
<p><img decoding="async" loading="lazy" src="/assets/images/3bc7773e-9b4f-4553-b29f-0a9e4400a4af-80771ef13b7c9db82d6481c759b8781a.png" width="771" height="507" class="img_ev3q"></p>
<p>可以看到，时间间隔变成一致的。这是因为SSH提供了一种基于时间的混淆技巧，让数据包的传输没有时间特征，从而避免了侧信道攻击。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="三terrapin-attack-攻击详情">三、Terrapin Attack 攻击详情<a href="#三terrapin-attack-攻击详情" class="hash-link" aria-label="三、Terrapin Attack 攻击详情的直接链接" title="三、Terrapin Attack 攻击详情的直接链接">​</a></h2>
<p>完成了之前那么多的前情提要，终于可以开始介绍这个攻击了。这个攻击针对的是SSH握手阶段发起的，这边要仔细介绍一下SSH的握手阶段发生的事情：</p>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="31-ssh握手阶段">3.1 SSH握手阶段<a href="#31-ssh握手阶段" class="hash-link" aria-label="3.1 SSH握手阶段的直接链接" title="3.1 SSH握手阶段的直接链接">​</a></h3>
<p>SSH从握手到建立加密通信信道的流程如下：</p>
<p><img decoding="async" loading="lazy" src="/assets/images/c775cdfe-4c27-486c-bd53-7c9f26582c24-23cd49d51725d9739c57a557fe47752f.png" width="923" height="722" class="img_ev3q"></p>
<p><em>其中黑色的部分表示当前信道已经是加密信道了，从黑色部分开始，中间人就完全无法解析SSH通信的具体内容。</em></p>
<p>上图有几个细节：</p>
<ul>
<li>SSH使用的是前文提到的二进制包协议（Binary Packet Protocol，之后简称BPP）；</li>
<li>通信在Newkeys之后才正式进入加密处理；</li>
<li>SSH加密的时候，会交换加密中用到的密钥，以及用于保护秘密信息的nonce；</li>
<li>这里生成的MAC值适用于检查信息的完整性，然而单纯生成普通的MAC值（例如，对明文进行hmac计算），攻击者很容易的就能使用各种方法对数据进行 伪造。此时就需要引入刚刚提到的nonce数据，以及计数器Counter；</li>
<li>SSH会使用<code>Snd</code> 和 <code>Rcv</code>两种不同的counter，前者会在发出数据包的时候自增，用于计算发出的数据包的MAC；后者会在接收到数据包的时候自增， 用于验证数据包的MAC，从而保证信道不被篡改。由于SSH是基于TCP协议的，所以被认为是<strong>不发生丢包的稳定通信</strong>，因此使用的counter为隐式counter；</li>
<li>Client和Server端的序列号都从0开始计数。</li>
</ul>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="311-kexinit">3.1.1 KEXINIT<a href="#311-kexinit" class="hash-link" aria-label="3.1.1 KEXINIT的直接链接" title="3.1.1 KEXINIT的直接链接">​</a></h4>
<p>在<code>KEXINIT</code>阶段（如图未加密），SSH会使用椭圆加密等手段进行nonces以及支持的算法列表进行交换。这里交换的四条算法列表包括：</p>
<ul>
<li>用于密钥交换的算法列表</li>
<li>用于服务端签名的算法</li>
<li>双边各使用的加密算法</li>
</ul>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="312-kexdhinit">3.1.2 KEXDHINIT<a href="#312-kexdhinit" class="hash-link" aria-label="3.1.2 KEXDHINIT的直接链接" title="3.1.2 KEXDHINIT的直接链接">​</a></h4>
<p>此时使用<code>Diff-Hellman</code>密钥交换算法进行数据交换。（也有可能使用ECDH或者PQC等算法）服务端会使用握手阶段中的<strong>数字签名</strong>对此时的数据信息进行校验。这个<strong>数字签名</strong>为之前提到的那些信息以某种固定的顺序进行计算的结果。</p>
<p>交换用hash：仅对部分数据校验。</p>
<p>这里提到的<strong>数字签名</strong>只会对通信数据中的部分数据进行计算。这里仅考虑了核心算法的内容，并没有把形如<strong>IGNORE MESSAGE</strong>这类消息一并纳入hash，或者其他的消息进行编码。这就给<code>MitM</code>创造了机会。</p>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="313-序列码">3.1.3 序列码<a href="#313-序列码" class="hash-link" aria-label="3.1.3 序列码的直接链接" title="3.1.3 序列码的直接链接">​</a></h4>
<p>为了对每一个数据包进行唯一性标记，这里使用了<code>Snd</code>和<code>Rcv</code>两种序列码共同标记。注意，在前几个序列中并不适用MAC对发送数据进行校验，而是等整个安全信道建立的时候，MAC才会参与数据校验。并且此时发送端的<code>Snd</code>必须要和接收端的<code>Rcv</code>相等，否则会直接抛弃当前数据包。</p>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="32-terrapin-attack-攻击细节">3.2 Terrapin Attack 攻击细节<a href="#32-terrapin-attack-攻击细节" class="hash-link" aria-label="3.2 Terrapin Attack 攻击细节的直接链接" title="3.2 Terrapin Attack 攻击细节的直接链接">​</a></h3>
<p>文章提出的是一种叫做<code>prefix truncation attacks</code>前缀截断攻击的一种攻击形式。这个攻击核心即为：</p>
<blockquote>
<p>The SSH Binary Packet Protocol is not a secure channel because a MitM attacker can delete a chosen number of integrity-protected packets from the beginning of the channel in either or both directions without being detected.</p>
</blockquote>
<p>简单来说，攻击的核心在于能够删除SSH通信过程中的<code>Counter Number</code>，从而能够突破其完整性校验，然后强迫SSH使用低安全性的加密算法，完成完整的漏洞攻击流程。在攻击中，会使用如下的术语：</p>
<ul>
<li><code>IGNORE</code>数据包：在SSH中，部分协议支持使用<code>IGNORE</code>数据包，即由一方发往另一方，但是无需对方回显的数据包；</li>
<li><code>UNKNOWN</code>数据包：在SSH中，如果当前数据包格式正常，但是却无法识别其类型，那么就会当成<code>UNKNOWN</code>数据包，对放则会回复一个<code>UNIMPLEMENT</code>的数据包 作为回应；</li>
<li><code>IV_kdf</code>：派生密钥，也就是例如CBC模式中，IV，或者<code>Enc(pi)</code>那个值，就叫做派生密钥。</li>
</ul>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="33-核心漏洞成因">3.3 核心漏洞成因<a href="#33-核心漏洞成因" class="hash-link" aria-label="3.3 核心漏洞成因的直接链接" title="3.3 核心漏洞成因的直接链接">​</a></h3>
<p>这个漏洞的核心成因为如下两点：</p>
<ul>
<li>未对握手阶段进行仔细校验。SSH在握手阶段使用了一个签名来校验完整性，但是并没有对所有的副本进行校验，而只是校验了某一个特定序列的信息；</li>
<li>SSH的安全会话序列号是从<strong>握手阶段开始算起的，而非建立起真正的安全信道的时候</strong>。这就会导致，在安全信道真的建立起来之前的序列号本质是不受到保护的。</li>
</ul>
<p>通过上述结论，我们可以使用如下的方式对目标进行攻击。</p>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="331-修改序列数">3.3.1 修改序列数<a href="#331-修改序列数" class="hash-link" aria-label="3.3.1 修改序列数的直接链接" title="3.3.1 修改序列数的直接链接">​</a></h4>
<p>通过在握手阶段插入一个数据包，我们可以增加<code>Rcv</code>的计数器。换句话说，攻击者可可以动态的修改这个<code>Snd</code>和<code>Rcv</code>值。</p>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="332-bbp上进行前缀截断攻击">3.3.2 BBP上进行前缀截断攻击<a href="#332-bbp上进行前缀截断攻击" class="hash-link" aria-label="3.3.2 BBP上进行前缀截断攻击的直接链接" title="3.3.2 BBP上进行前缀截断攻击的直接链接">​</a></h4>
<p>核心攻击技巧：攻击者可以通过使用序列号控制来<strong>动态的删除一个安全信道建立之初的数据包。</strong></p>
<p><img decoding="async" loading="lazy" src="/assets/images/36ac6534-cbe6-4d16-ba79-f4494a6b0e59-9c3423dbce2bbd5533788a5a69432b30.png" width="793" height="689" class="img_ev3q"></p>
<p>在SSH通信过程中，如果接收方的<code>Rcv</code>与发送方的<code>Snd</code>不匹配，此时就会抛弃这个数据包。这个攻击就是利用了这个机制，使得SSH会将关键的数据包进行抛弃。 通过上述操作，可以发动如下的攻击：</p>
<p><strong>1. BBP上进行多段前缀截断攻击</strong> 攻击者可以通过往Client或者Server段一次性发送多个特殊的<code>IGNORE</code>数据包，从而引发多个数据包丢失，造成多段截断攻击。</p>
<p><strong>2. 扩展协议降级攻击</strong> 在SSH通信中，会使用<code>EXTINFO</code>来标注当前的SSH支持的扩展协议。然而攻击者可以通过丢弃这个<code>EXTINFO</code>，造成<code>Extension Negotiation</code>，迫使安全信道降级，让服务端以为客户端无法支持这几年的安全的协议，从而迫使服务端改用可以被测信道攻击<code>keystroke timing attack</code>的老旧协议</p>
<p><strong>3. 恶意扩展攻击和恶意会话攻击</strong> 在例如<code>AsyncSSH</code>这类SSH实现端上。当攻击者拥有受害者的用户名的时候，可以通过插入一个带有用户认证信息的数据包，此时受害者会直接登陆到攻击者的shell环境上，实现整个会话的劫持。</p>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="333-适用范围">3.3.3 适用范围<a href="#333-适用范围" class="hash-link" aria-label="3.3.3 适用范围的直接链接" title="3.3.3 适用范围的直接链接">​</a></h4>
<p>攻击对于<code>ChaCha20Poly1305</code>这种<code>AEAD</code>的加密方式很好，也同样可以用于部分<code>CBC-EtM</code>模式中。但是，<code>CBC-EaM,CTR-EaM,GCM</code>这三种模式都是不受到这个攻击影响的。如果之前没有了解过这类算法，可以参考<a href="https://zhuanlan.zhihu.com/p/28566058" target="_blank" rel="noopener noreferrer">这里</a>。</p>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="334-cbc-etm-与出错处理">3.3.4 CBC-EtM 与出错处理<a href="#334-cbc-etm-与出错处理" class="hash-link" aria-label="3.3.4 CBC-EtM 与出错处理的直接链接" title="3.3.4 CBC-EtM 与出错处理的直接链接">​</a></h4>
<p>实际上，某些算法中的<code>EtM</code>未就能够绕过check，例如<code>CTR-EtM</code>中，由于Counter的介入，当我们丢弃数据包的时候，Counter会发生错位，从而导致出错。所以，这里特指<code>CBC-EtM</code>。而<code>CBC-EtM</code>也并非完全可靠。我们举个例子，在CBC加密模式下，明文计算公式为：p1=Dec(c1) xor IV_kdf。</p>
<p>那么假设此时，我们使用扩展协议降级攻击，使得前面k个数据包丢失，那么此时的计算为：</p>
<p>p’1 = Dec(ck+1) xor IV_kdf</p>
<p>此时我们的p1值就是未知的了，而且可能是无效的。然而根据CBC的特性可知，此后的值都是没问题的：</p>
<p>p’2 = pk+2 = Dec(ck+2) xor ck+1</p>
<p>所以这里就产生了一个疑问，SSH究竟会如何处理这个可能有问题的数据包呢？这里有三种可能：</p>
<ul>
<li>数据包出错过于离谱，直接将数据包抛弃；</li>
<li>数据包虽然出错，但是关键部分的数据是可以识别的，此时SSH会将这个包当作正常的数据包进行使用；</li>
<li>数据包虽然能解析，但是无法解析，此时将数据包视为<code>UNKOWN</code>数据包，并且给出<code>UNIMPLEMENT</code>回显。</li>
</ul>
<p>接下来，就会展示一些可能的攻击场景，描述当前攻击的可行性。</p>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="34-具体实例chacha20-poly1305">3.4 具体实例：ChaCha20-Poly1305<a href="#34-具体实例chacha20-poly1305" class="hash-link" aria-label="3.4 具体实例：ChaCha20-Poly1305的直接链接" title="3.4 具体实例：ChaCha20-Poly1305的直接链接">​</a></h3>
<p>SSH算法会在<code>NEWKEYS</code>阶段后，建立加密隧道，并且在加密信道中发送<code>EXTINFO</code>相关信息，提供一些扩展加密策略，从而防止各种形如测信道攻击<code>keystroke timing attack</code>的攻击策略。此时我们可以使用单个包的丢失阶段技巧后，可以使其丢弃对应的扩展加密策略，从而迫使其使用不太安全的通信策略：</p>
<p><img decoding="async" loading="lazy" src="/assets/images/aa7571cc-1464-429f-b7c7-3c776974baae-9c3423dbce2bbd5533788a5a69432b30.png" width="793" height="689" class="img_ev3q"></p>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="35-具体实例-cbc-etm">3.5 具体实例： CBC-EtM<a href="#35-具体实例-cbc-etm" class="hash-link" aria-label="3.5 具体实例： CBC-EtM的直接链接" title="3.5 具体实例： CBC-EtM的直接链接">​</a></h3>
<p>此攻击同样是逼迫SSH丢弃<code>EXTINFO</code>相关信息。然而正如前文所说，对于类似<code>CBC</code>这种模式，其解密逻辑原先如下:</p>
<p>P1 = IV xor Dec(C1)</p>
<p>如果我们用<code>IGNORE</code>丢弃一个数据包的话，数据会变成：</p>
<p>P1(?) = IV xor Dec(C2)</p>
<p>P2(?) = IV xor Dec(C3)</p>
<p>这样有生成的所有密文都会被影响，从而使攻击失效。于是此时我们可以使用另一种策略强行让其丢弃<code>EXTINFO</code>，那就是使用一种服务器无法解析的<code>UNKNOWN</code>信息。此时服务端返回<code>UNIMPLEMENT</code>。这种办法可以迫使Server端使用<code>UNIMPELEMENT</code>数据包替换<code>EXTINFO</code>，这样办法就能保证往后的密文解析没问题。</p>
<p><img decoding="async" loading="lazy" src="/assets/images/df86fe32-9154-4873-99e8-3aeca4808175-69876f6ca7bc74095f25cd22c975a577.png" width="652" height="598" class="img_ev3q"></p>
<p>如图，首先通过在Client端发送<code>UNKNOWN</code>，使其能够保持对齐，然后通过在合适位置往Server端插入<code>UNKNOWN</code>信息，即可保证在通信过程中依然能够截获<code>EXT_INFO</code>。</p>
<p>然而<code>UNIMPLEMENT</code>信息通常较短，可能会导致数据错位（没能填满Block，或者因为<code>EXT_INFO</code>导致错位等等）使得数据解密发生错误。然而，在部分SSH客户端中，我们可以使用<code>PING-PONG</code>包代替这种包，通过在<code>PING</code>数据包中塞入大量的数据，此时返回的<code>PONG</code>将很有可能能够符合SSH客户端接受数据的要求，此时准确率就会提升非常多。</p>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="36-具体攻击-asyncssh">3.6 具体攻击 AsyncSSH<a href="#36-具体攻击-asyncssh" class="hash-link" aria-label="3.6 具体攻击 AsyncSSH的直接链接" title="3.6 具体攻击 AsyncSSH的直接链接">​</a></h3>
<p>如果说之前的说法都是理论上的泛泛而谈，这边就要举一个实际的例子：<a href="https://github.com/ronf/asyncssh" target="_blank" rel="noopener noreferrer">asyncssh</a>，这个库是一个python里面的有名的库。并且其就受到这种攻击的影响。这里介绍两种实际的攻击形式。</p>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="361-恶意使用extinfo">3.6.1 恶意使用<code>EXTINFO</code><a href="#361-恶意使用extinfo" class="hash-link" aria-label="361-恶意使用extinfo的直接链接" title="361-恶意使用extinfo的直接链接">​</a></h4>
<p>这里的打法和<code>ChaCha20-Poly1305</code>类似，不过将<code>IGNORE</code>替换成了指定的<code>EXTINFO</code>。理论上来说，<code>EXTINFO</code>应该在加密信道中进行接收，但是AsyncSSH可以接受任何时候发送的<code>EXTINFO</code>，于是配合前面提到的前缀截断攻击，可以将原先的安全的SSH协议替换成我们指定的SSH协议。</p>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="362-劫持ssh会话要求有一个能够ssh的用户信息">3.6.2 劫持SSH会话，要求有一个能够SSH的用户信息<a href="#362-劫持ssh会话要求有一个能够ssh的用户信息" class="hash-link" aria-label="3.6.2 劫持SSH会话，要求有一个能够SSH的用户信息的直接链接" title="3.6.2 劫持SSH会话，要求有一个能够SSH的用户信息的直接链接">​</a></h4>
<p>这种攻击需要攻击者在这个SSH服务端上也有一个登陆凭证。这种攻击能够让用户以攻击者指定的用户登录，但是毫无察觉。在这种场景下，攻击者能轻易的获取受害者的所有输入，甚至作为一个伪造的SSH Agent存在。这种攻击如图：</p>
<p><img decoding="async" loading="lazy" src="/assets/images/6296bb77-92b0-4744-9f51-7f0d7e54e3e7-0da6c7f3da6f0c9aa830c75156aa57d6.png" width="647" height="559" class="img_ev3q"></p>
<p>首先在客户的<code>NEWKEYS</code>之前，插入一个<code>USER_AUTHREQUEST</code>请求，这个请求中包含了攻击者指定的认证信息（最好使用<code>password</code>或者<code>publickey</code>机制）。此时，AsyncSSH的服务器端会认为其接收到了认证信息，但是由于还没有完成握手机制（<code>NEWKEYS</code>未完成），所以其仍会等待对应的流程完成。之后用户端发起<code>SERVICE_REQUEST</code>，要求进行认证后，服务端此时发送<code>SERVICE_ACCEPT</code>，表示可以进行认证。然而我们之前已经伪造了一个<code>USER_AUTHREQUEST</code>请求，此时AsyncSSH的服务端会认为我们已经完成了请求，于是返回<code>USERAUTH_SUCCESS</code>，表示可建立通讯通道。</p>
<p>期间为了防止Client的正常行为从而导致攻击者的登录被取代，以及防止Client察觉，这里故意将真正的<code>USER_AUTHREQUEST</code>滞后，此时当服务器端返回请求后，攻击者再将这个请求发往对面。然而此时因为认为通道已经建立，这个登录请求就被抛弃了。</p>
<p>Q：为什么这个时候还要发送真正的<code>USER_AUTHREQUEST</code>呢？</p>
<p>A：因为丢弃数据会引发<code>CBC-MtE</code>解密错误，所以只能延后，不能丢弃。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="四总结">四、总结<a href="#四总结" class="hash-link" aria-label="四、总结的直接链接" title="四、总结的直接链接">​</a></h2>
<p>这个攻击模型非常有趣，其中无论是利用SSH机制的部分，还是通过替换数据包 or 丢弃数据包从而绕过MAC完整性的办法都是非常有趣的地方。在今后的安全研究中，需要试着从不同的角度去考虑攻击场景以及防护场景，才能更好的对安全有一个广泛的认知。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="五参考链接">五、参考链接<a href="#五参考链接" class="hash-link" aria-label="五、参考链接的直接链接" title="五、参考链接的直接链接">​</a></h2>
<p><a href="https://jfrog.com/blog/ssh-protocol-flaw-terrapin-attack-cve-2023-48795-all-you-need-to-know/" target="_blank" rel="noopener noreferrer">SSH protocol flaw – Terrapin Attack CVE-2023-48795: All you need to know</a></p>
<p><a href="https://terrapin-attack.com/" target="_blank" rel="noopener noreferrer">Terrapin Attack</a></p>
<p><a href="https://conferences.computer.org/sp/pdfs/sp/2009/oakland2009-01.pdf" target="_blank" rel="noopener noreferrer">Plaintext Recovery Attacks Against SSH</a></p>
<p><a href="https://www.usenix.org/conference/10th-usenix-security-symposium/timing-analysis-keystrokes-and-timing-attacks-ssh" target="_blank" rel="noopener noreferrer">Timing Analysis of Keystrokes and Timing Attacks on SSH</a></p></div><footer class="row docusaurus-mt-lg blogPostFooterDetailsFull_mRVl"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/terrapin">Terrapin</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/ssh">SSH</a></li></ul></div><div class="col margin-top--sm"><a href="https://github.com/TianGongLab/poc_docs/tree/main/blog/2024-01-31-terrapin/index.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="博文分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/tiangongarticle018"><div class="pagination-nav__sublabel">较新一篇</div><div class="pagination-nav__label">WebAssembly安全研究总结</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/tiangongarticle016"><div class="pagination-nav__sublabel">较旧一篇</div><div class="pagination-nav__label">常见 PHP 源码保护与还原</div></a></nav><div style="margin-top:20px"></div></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#一terrapin-attack-背景探讨" class="table-of-contents__link toc-highlight">一、Terrapin Attack 背景探讨</a><ul><li><a href="#11-通信完整性定义" class="table-of-contents__link toc-highlight">1.1 通信完整性定义</a></li><li><a href="#12-如何算是对ssh发起攻击" class="table-of-contents__link toc-highlight">1.2 如何算是对SSH发起攻击</a></li></ul></li><li><a href="#二ssh-历史问题" class="table-of-contents__link toc-highlight">二、SSH 历史问题</a><ul><li><a href="#21-ssh前置知识补充" class="table-of-contents__link toc-highlight">2.1 SSH前置知识补充</a></li><li><a href="#22-cve-2008-5161-针对me的攻击介绍" class="table-of-contents__link toc-highlight">2.2 CVE-2008-5161 针对M&amp;E的攻击介绍</a></li><li><a href="#23-cve-2008-5161中间人攻击" class="table-of-contents__link toc-highlight">2.3 CVE-2008-5161 中间人攻击</a></li><li><a href="#24-侧信道攻击-keystroke-timing-attack" class="table-of-contents__link toc-highlight">2.4 侧信道攻击 keystroke timing attack</a></li></ul></li><li><a href="#三terrapin-attack-攻击详情" class="table-of-contents__link toc-highlight">三、Terrapin Attack 攻击详情</a><ul><li><a href="#31-ssh握手阶段" class="table-of-contents__link toc-highlight">3.1 SSH握手阶段</a></li><li><a href="#32-terrapin-attack-攻击细节" class="table-of-contents__link toc-highlight">3.2 Terrapin Attack 攻击细节</a></li><li><a href="#33-核心漏洞成因" class="table-of-contents__link toc-highlight">3.3 核心漏洞成因</a></li><li><a href="#34-具体实例chacha20-poly1305" class="table-of-contents__link toc-highlight">3.4 具体实例：ChaCha20-Poly1305</a></li><li><a href="#35-具体实例-cbc-etm" class="table-of-contents__link toc-highlight">3.5 具体实例： CBC-EtM</a></li><li><a href="#36-具体攻击-asyncssh" class="table-of-contents__link toc-highlight">3.6 具体攻击 AsyncSSH</a></li></ul></li><li><a href="#四总结" class="table-of-contents__link toc-highlight">四、总结</a></li><li><a href="#五参考链接" class="table-of-contents__link toc-highlight">五、参考链接</a></li></ul></div></div></div></div></div></div>
</body>
</html>